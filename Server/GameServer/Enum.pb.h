// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Enum.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Enum_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Enum_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Enum_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Enum_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Enum_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

enum ECharacterType : int {
  WARRIOR = 0,
  ROGUE = 1,
  WIZARD = 2,
  MONSTER = 3,
  NONE = 4,
  ECharacterType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ECharacterType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ECharacterType_IsValid(int value);
constexpr ECharacterType ECharacterType_MIN = WARRIOR;
constexpr ECharacterType ECharacterType_MAX = NONE;
constexpr int ECharacterType_ARRAYSIZE = ECharacterType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ECharacterType_descriptor();
template<typename T>
inline const std::string& ECharacterType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ECharacterType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ECharacterType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ECharacterType_descriptor(), enum_t_value);
}
inline bool ECharacterType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ECharacterType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ECharacterType>(
    ECharacterType_descriptor(), name, value);
}
enum EState : int {
  STATE_NONE = 0,
  STATE_IDLE = 1,
  STATE_MOVE = 2,
  STATE_RUN = 3,
  STATE_ATTACK = 4,
  STATE_SKILL = 5,
  STATE_DAMAGED = 6,
  STATE_DEAD = 7,
  STATE_JUMP = 8,
  EState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EState_IsValid(int value);
constexpr EState EState_MIN = STATE_NONE;
constexpr EState EState_MAX = STATE_JUMP;
constexpr int EState_ARRAYSIZE = EState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EState_descriptor();
template<typename T>
inline const std::string& EState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EState_descriptor(), enum_t_value);
}
inline bool EState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EState>(
    EState_descriptor(), name, value);
}
enum EQuickSlot : int {
  QUICK_0 = 0,
  QUICK_1 = 1,
  QUICK_2 = 2,
  QUICK_3 = 3,
  QUICK_4 = 4,
  QUICK_5 = 5,
  QUICK_6 = 6,
  QUICK_7 = 7,
  QUICK_8 = 8,
  QUICK_9 = 9,
  QUICK_Q = 10,
  QUICK_E = 11,
  QUICK_R = 12,
  QUICK_C = 13,
  QUICK_V = 14,
  QUICK_T = 15,
  QUICK_NONE = 16,
  EQuickSlot_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EQuickSlot_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EQuickSlot_IsValid(int value);
constexpr EQuickSlot EQuickSlot_MIN = QUICK_0;
constexpr EQuickSlot EQuickSlot_MAX = QUICK_NONE;
constexpr int EQuickSlot_ARRAYSIZE = EQuickSlot_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EQuickSlot_descriptor();
template<typename T>
inline const std::string& EQuickSlot_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EQuickSlot>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EQuickSlot_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EQuickSlot_descriptor(), enum_t_value);
}
inline bool EQuickSlot_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EQuickSlot* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EQuickSlot>(
    EQuickSlot_descriptor(), name, value);
}
enum EQuickElementType : int {
  QUICK_ITEM = 0,
  QUICK_SKILL = 1,
  EQuickElementType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EQuickElementType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EQuickElementType_IsValid(int value);
constexpr EQuickElementType EQuickElementType_MIN = QUICK_ITEM;
constexpr EQuickElementType EQuickElementType_MAX = QUICK_SKILL;
constexpr int EQuickElementType_ARRAYSIZE = EQuickElementType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EQuickElementType_descriptor();
template<typename T>
inline const std::string& EQuickElementType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EQuickElementType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EQuickElementType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EQuickElementType_descriptor(), enum_t_value);
}
inline bool EQuickElementType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EQuickElementType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EQuickElementType>(
    EQuickElementType_descriptor(), name, value);
}
enum EPlayerData : int {
  DATA_ATTACKABLE = 0,
  DATA_UNATTACKABLE = 1,
  DATA_IDLE = 2,
  EPlayerData_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EPlayerData_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EPlayerData_IsValid(int value);
constexpr EPlayerData EPlayerData_MIN = DATA_ATTACKABLE;
constexpr EPlayerData EPlayerData_MAX = DATA_IDLE;
constexpr int EPlayerData_ARRAYSIZE = EPlayerData_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EPlayerData_descriptor();
template<typename T>
inline const std::string& EPlayerData_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EPlayerData>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EPlayerData_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EPlayerData_descriptor(), enum_t_value);
}
inline bool EPlayerData_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EPlayerData* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EPlayerData>(
    EPlayerData_descriptor(), name, value);
}
enum ENpcType : int {
  NPC_NORMAL = 0,
  NPC_WEAPON = 1,
  NPC_ARMOR = 2,
  NPC_CONSUMABLE = 3,
  ENpcType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ENpcType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ENpcType_IsValid(int value);
constexpr ENpcType ENpcType_MIN = NPC_NORMAL;
constexpr ENpcType ENpcType_MAX = NPC_CONSUMABLE;
constexpr int ENpcType_ARRAYSIZE = ENpcType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ENpcType_descriptor();
template<typename T>
inline const std::string& ENpcType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ENpcType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ENpcType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ENpcType_descriptor(), enum_t_value);
}
inline bool ENpcType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ENpcType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ENpcType>(
    ENpcType_descriptor(), name, value);
}
enum EItemType : int {
  ITEM_WEAPON = 0,
  ITEM_ARMOR = 1,
  ITEM_CONSUMABLE = 2,
  EItemType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EItemType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EItemType_IsValid(int value);
constexpr EItemType EItemType_MIN = ITEM_WEAPON;
constexpr EItemType EItemType_MAX = ITEM_CONSUMABLE;
constexpr int EItemType_ARRAYSIZE = EItemType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EItemType_descriptor();
template<typename T>
inline const std::string& EItemType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EItemType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EItemType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EItemType_descriptor(), enum_t_value);
}
inline bool EItemType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EItemType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EItemType>(
    EItemType_descriptor(), name, value);
}
enum EItemGrade : int {
  GRADE_NORMAL = 0,
  GRADE_RARE = 1,
  EItemGrade_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EItemGrade_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EItemGrade_IsValid(int value);
constexpr EItemGrade EItemGrade_MIN = GRADE_NORMAL;
constexpr EItemGrade EItemGrade_MAX = GRADE_RARE;
constexpr int EItemGrade_ARRAYSIZE = EItemGrade_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EItemGrade_descriptor();
template<typename T>
inline const std::string& EItemGrade_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EItemGrade>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EItemGrade_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EItemGrade_descriptor(), enum_t_value);
}
inline bool EItemGrade_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EItemGrade* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EItemGrade>(
    EItemGrade_descriptor(), name, value);
}
enum EHealType : int {
  HEAL_HP = 0,
  HEAL_MP = 1,
  EHealType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EHealType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EHealType_IsValid(int value);
constexpr EHealType EHealType_MIN = HEAL_HP;
constexpr EHealType EHealType_MAX = HEAL_MP;
constexpr int EHealType_ARRAYSIZE = EHealType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EHealType_descriptor();
template<typename T>
inline const std::string& EHealType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EHealType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EHealType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EHealType_descriptor(), enum_t_value);
}
inline bool EHealType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EHealType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EHealType>(
    EHealType_descriptor(), name, value);
}
enum ESlotState : int {
  SLOT_NONE = 0,
  SLOT_EQUIPPED = 1,
  SLOT_INVENTORY = 2,
  SLOT_WAREHOUSE = 3,
  ESlotState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ESlotState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ESlotState_IsValid(int value);
constexpr ESlotState ESlotState_MIN = SLOT_NONE;
constexpr ESlotState ESlotState_MAX = SLOT_WAREHOUSE;
constexpr int ESlotState_ARRAYSIZE = ESlotState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESlotState_descriptor();
template<typename T>
inline const std::string& ESlotState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESlotState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESlotState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESlotState_descriptor(), enum_t_value);
}
inline bool ESlotState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESlotState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESlotState>(
    ESlotState_descriptor(), name, value);
}
enum EGetItemType : int {
  GET_DROP = 0,
  GET_BUY = 1,
  EGetItemType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EGetItemType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EGetItemType_IsValid(int value);
constexpr EGetItemType EGetItemType_MIN = GET_DROP;
constexpr EGetItemType EGetItemType_MAX = GET_BUY;
constexpr int EGetItemType_ARRAYSIZE = EGetItemType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EGetItemType_descriptor();
template<typename T>
inline const std::string& EGetItemType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EGetItemType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EGetItemType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EGetItemType_descriptor(), enum_t_value);
}
inline bool EGetItemType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EGetItemType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EGetItemType>(
    EGetItemType_descriptor(), name, value);
}
enum EWeaponData : int {
  WEAPON_TWOHANDS = 0,
  WEAPON_DAGGER = 1,
  WEAPON_STAFF = 2,
  EWeaponData_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EWeaponData_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EWeaponData_IsValid(int value);
constexpr EWeaponData EWeaponData_MIN = WEAPON_TWOHANDS;
constexpr EWeaponData EWeaponData_MAX = WEAPON_STAFF;
constexpr int EWeaponData_ARRAYSIZE = EWeaponData_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EWeaponData_descriptor();
template<typename T>
inline const std::string& EWeaponData_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EWeaponData>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EWeaponData_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EWeaponData_descriptor(), enum_t_value);
}
inline bool EWeaponData_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EWeaponData* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EWeaponData>(
    EWeaponData_descriptor(), name, value);
}
enum EArmorData : int {
  ARMOR_HELMET = 0,
  ARMOR_TOP = 1,
  ARMOR_BOTTOM = 2,
  ARMOR_BOOTS = 3,
  ARMOR_GLOVES = 4,
  EArmorData_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EArmorData_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EArmorData_IsValid(int value);
constexpr EArmorData EArmorData_MIN = ARMOR_HELMET;
constexpr EArmorData EArmorData_MAX = ARMOR_GLOVES;
constexpr int EArmorData_ARRAYSIZE = EArmorData_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EArmorData_descriptor();
template<typename T>
inline const std::string& EArmorData_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EArmorData>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EArmorData_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EArmorData_descriptor(), enum_t_value);
}
inline bool EArmorData_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EArmorData* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EArmorData>(
    EArmorData_descriptor(), name, value);
}
enum EStatChangeType : int {
  STAT_HP = 0,
  STAT_MP = 1,
  STAT_EXP = 2,
  STAT_LEVEL = 3,
  EStatChangeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EStatChangeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EStatChangeType_IsValid(int value);
constexpr EStatChangeType EStatChangeType_MIN = STAT_HP;
constexpr EStatChangeType EStatChangeType_MAX = STAT_LEVEL;
constexpr int EStatChangeType_ARRAYSIZE = EStatChangeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStatChangeType_descriptor();
template<typename T>
inline const std::string& EStatChangeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStatChangeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStatChangeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStatChangeType_descriptor(), enum_t_value);
}
inline bool EStatChangeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStatChangeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStatChangeType>(
    EStatChangeType_descriptor(), name, value);
}
enum EQuestGrade : int {
  QUEST_MAIN = 0,
  QUEST_NORMAL = 1,
  EQuestGrade_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EQuestGrade_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EQuestGrade_IsValid(int value);
constexpr EQuestGrade EQuestGrade_MIN = QUEST_MAIN;
constexpr EQuestGrade EQuestGrade_MAX = QUEST_NORMAL;
constexpr int EQuestGrade_ARRAYSIZE = EQuestGrade_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EQuestGrade_descriptor();
template<typename T>
inline const std::string& EQuestGrade_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EQuestGrade>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EQuestGrade_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EQuestGrade_descriptor(), enum_t_value);
}
inline bool EQuestGrade_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EQuestGrade* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EQuestGrade>(
    EQuestGrade_descriptor(), name, value);
}
enum EQuestState : int {
  QUEST_AVAILABLE = 0,
  QUEST_ACCEPT = 1,
  QUEST_COMPLETABLE = 2,
  QUEST_COMPLETED = 3,
  QUEST_ABANDON = 4,
  QUEST_NOTCOMPLETABLE = 5,
  EQuestState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EQuestState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EQuestState_IsValid(int value);
constexpr EQuestState EQuestState_MIN = QUEST_AVAILABLE;
constexpr EQuestState EQuestState_MAX = QUEST_NOTCOMPLETABLE;
constexpr int EQuestState_ARRAYSIZE = EQuestState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EQuestState_descriptor();
template<typename T>
inline const std::string& EQuestState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EQuestState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EQuestState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EQuestState_descriptor(), enum_t_value);
}
inline bool EQuestState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EQuestState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EQuestState>(
    EQuestState_descriptor(), name, value);
}
enum ETargetType : int {
  TARGET_MONSTER = 0,
  TARGET_NPC = 1,
  TARGET_CONSUMABLE = 2,
  TARGET_MISC = 3,
  ETargetType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ETargetType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ETargetType_IsValid(int value);
constexpr ETargetType ETargetType_MIN = TARGET_MONSTER;
constexpr ETargetType ETargetType_MAX = TARGET_MISC;
constexpr int ETargetType_ARRAYSIZE = ETargetType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ETargetType_descriptor();
template<typename T>
inline const std::string& ETargetType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ETargetType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ETargetType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ETargetType_descriptor(), enum_t_value);
}
inline bool ETargetType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ETargetType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ETargetType>(
    ETargetType_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Protocol::ECharacterType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::ECharacterType>() {
  return ::Protocol::ECharacterType_descriptor();
}
template <> struct is_proto_enum< ::Protocol::EState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::EState>() {
  return ::Protocol::EState_descriptor();
}
template <> struct is_proto_enum< ::Protocol::EQuickSlot> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::EQuickSlot>() {
  return ::Protocol::EQuickSlot_descriptor();
}
template <> struct is_proto_enum< ::Protocol::EQuickElementType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::EQuickElementType>() {
  return ::Protocol::EQuickElementType_descriptor();
}
template <> struct is_proto_enum< ::Protocol::EPlayerData> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::EPlayerData>() {
  return ::Protocol::EPlayerData_descriptor();
}
template <> struct is_proto_enum< ::Protocol::ENpcType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::ENpcType>() {
  return ::Protocol::ENpcType_descriptor();
}
template <> struct is_proto_enum< ::Protocol::EItemType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::EItemType>() {
  return ::Protocol::EItemType_descriptor();
}
template <> struct is_proto_enum< ::Protocol::EItemGrade> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::EItemGrade>() {
  return ::Protocol::EItemGrade_descriptor();
}
template <> struct is_proto_enum< ::Protocol::EHealType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::EHealType>() {
  return ::Protocol::EHealType_descriptor();
}
template <> struct is_proto_enum< ::Protocol::ESlotState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::ESlotState>() {
  return ::Protocol::ESlotState_descriptor();
}
template <> struct is_proto_enum< ::Protocol::EGetItemType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::EGetItemType>() {
  return ::Protocol::EGetItemType_descriptor();
}
template <> struct is_proto_enum< ::Protocol::EWeaponData> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::EWeaponData>() {
  return ::Protocol::EWeaponData_descriptor();
}
template <> struct is_proto_enum< ::Protocol::EArmorData> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::EArmorData>() {
  return ::Protocol::EArmorData_descriptor();
}
template <> struct is_proto_enum< ::Protocol::EStatChangeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::EStatChangeType>() {
  return ::Protocol::EStatChangeType_descriptor();
}
template <> struct is_proto_enum< ::Protocol::EQuestGrade> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::EQuestGrade>() {
  return ::Protocol::EQuestGrade_descriptor();
}
template <> struct is_proto_enum< ::Protocol::EQuestState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::EQuestState>() {
  return ::Protocol::EQuestState_descriptor();
}
template <> struct is_proto_enum< ::Protocol::ETargetType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protocol::ETargetType>() {
  return ::Protocol::ETargetType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Enum_2eproto
