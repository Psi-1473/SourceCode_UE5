// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "Enum.pb.h"
#include "Struct.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Protocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Protocol_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Protocol_2eproto;
namespace Protocol {
class C_ADDITEM;
struct C_ADDITEMDefaultTypeInternal;
extern C_ADDITEMDefaultTypeInternal _C_ADDITEM_default_instance_;
class C_ATTACK;
struct C_ATTACKDefaultTypeInternal;
extern C_ATTACKDefaultTypeInternal _C_ATTACK_default_instance_;
class C_CHAT;
struct C_CHATDefaultTypeInternal;
extern C_CHATDefaultTypeInternal _C_CHAT_default_instance_;
class C_CHECKNAME;
struct C_CHECKNAMEDefaultTypeInternal;
extern C_CHECKNAMEDefaultTypeInternal _C_CHECKNAME_default_instance_;
class C_CREATECHARACTER;
struct C_CREATECHARACTERDefaultTypeInternal;
extern C_CREATECHARACTERDefaultTypeInternal _C_CREATECHARACTER_default_instance_;
class C_ENTER_GAME;
struct C_ENTER_GAMEDefaultTypeInternal;
extern C_ENTER_GAMEDefaultTypeInternal _C_ENTER_GAME_default_instance_;
class C_EQUIP;
struct C_EQUIPDefaultTypeInternal;
extern C_EQUIPDefaultTypeInternal _C_EQUIP_default_instance_;
class C_ITEMSWAP;
struct C_ITEMSWAPDefaultTypeInternal;
extern C_ITEMSWAPDefaultTypeInternal _C_ITEMSWAP_default_instance_;
class C_LEAVE_GAME;
struct C_LEAVE_GAMEDefaultTypeInternal;
extern C_LEAVE_GAMEDefaultTypeInternal _C_LEAVE_GAME_default_instance_;
class C_LOAD_INFO;
struct C_LOAD_INFODefaultTypeInternal;
extern C_LOAD_INFODefaultTypeInternal _C_LOAD_INFO_default_instance_;
class C_LOGIN;
struct C_LOGINDefaultTypeInternal;
extern C_LOGINDefaultTypeInternal _C_LOGIN_default_instance_;
class C_MOVE;
struct C_MOVEDefaultTypeInternal;
extern C_MOVEDefaultTypeInternal _C_MOVE_default_instance_;
class C_QUEST;
struct C_QUESTDefaultTypeInternal;
extern C_QUESTDefaultTypeInternal _C_QUEST_default_instance_;
class C_QUICK_QUEST;
struct C_QUICK_QUESTDefaultTypeInternal;
extern C_QUICK_QUESTDefaultTypeInternal _C_QUICK_QUEST_default_instance_;
class C_REMOVEITEM;
struct C_REMOVEITEMDefaultTypeInternal;
extern C_REMOVEITEMDefaultTypeInternal _C_REMOVEITEM_default_instance_;
class C_RENEW_TARGET;
struct C_RENEW_TARGETDefaultTypeInternal;
extern C_RENEW_TARGETDefaultTypeInternal _C_RENEW_TARGET_default_instance_;
class C_SETGOLD;
struct C_SETGOLDDefaultTypeInternal;
extern C_SETGOLDDefaultTypeInternal _C_SETGOLD_default_instance_;
class C_SET_QUICK;
struct C_SET_QUICKDefaultTypeInternal;
extern C_SET_QUICKDefaultTypeInternal _C_SET_QUICK_default_instance_;
class C_UNEQUIP;
struct C_UNEQUIPDefaultTypeInternal;
extern C_UNEQUIPDefaultTypeInternal _C_UNEQUIP_default_instance_;
class C_UPGRADESKILL;
struct C_UPGRADESKILLDefaultTypeInternal;
extern C_UPGRADESKILLDefaultTypeInternal _C_UPGRADESKILL_default_instance_;
class C_USEITEM;
struct C_USEITEMDefaultTypeInternal;
extern C_USEITEMDefaultTypeInternal _C_USEITEM_default_instance_;
class C_USESKILL;
struct C_USESKILLDefaultTypeInternal;
extern C_USESKILLDefaultTypeInternal _C_USESKILL_default_instance_;
class S_ADDITEM;
struct S_ADDITEMDefaultTypeInternal;
extern S_ADDITEMDefaultTypeInternal _S_ADDITEM_default_instance_;
class S_ATTACK;
struct S_ATTACKDefaultTypeInternal;
extern S_ATTACKDefaultTypeInternal _S_ATTACK_default_instance_;
class S_CHAT;
struct S_CHATDefaultTypeInternal;
extern S_CHATDefaultTypeInternal _S_CHAT_default_instance_;
class S_CHECKNAME;
struct S_CHECKNAMEDefaultTypeInternal;
extern S_CHECKNAMEDefaultTypeInternal _S_CHECKNAME_default_instance_;
class S_DAMAGED;
struct S_DAMAGEDDefaultTypeInternal;
extern S_DAMAGEDDefaultTypeInternal _S_DAMAGED_default_instance_;
class S_DESPAWN;
struct S_DESPAWNDefaultTypeInternal;
extern S_DESPAWNDefaultTypeInternal _S_DESPAWN_default_instance_;
class S_DIE;
struct S_DIEDefaultTypeInternal;
extern S_DIEDefaultTypeInternal _S_DIE_default_instance_;
class S_ENTER_GAME;
struct S_ENTER_GAMEDefaultTypeInternal;
extern S_ENTER_GAMEDefaultTypeInternal _S_ENTER_GAME_default_instance_;
class S_EQUIP;
struct S_EQUIPDefaultTypeInternal;
extern S_EQUIPDefaultTypeInternal _S_EQUIP_default_instance_;
class S_LEAVE_GAME;
struct S_LEAVE_GAMEDefaultTypeInternal;
extern S_LEAVE_GAMEDefaultTypeInternal _S_LEAVE_GAME_default_instance_;
class S_LEVEL_UP;
struct S_LEVEL_UPDefaultTypeInternal;
extern S_LEVEL_UPDefaultTypeInternal _S_LEVEL_UP_default_instance_;
class S_LOAD_QUICK;
struct S_LOAD_QUICKDefaultTypeInternal;
extern S_LOAD_QUICKDefaultTypeInternal _S_LOAD_QUICK_default_instance_;
class S_LOAD_SKILL;
struct S_LOAD_SKILLDefaultTypeInternal;
extern S_LOAD_SKILLDefaultTypeInternal _S_LOAD_SKILL_default_instance_;
class S_LOAD_TARGET;
struct S_LOAD_TARGETDefaultTypeInternal;
extern S_LOAD_TARGETDefaultTypeInternal _S_LOAD_TARGET_default_instance_;
class S_LOGIN;
struct S_LOGINDefaultTypeInternal;
extern S_LOGINDefaultTypeInternal _S_LOGIN_default_instance_;
class S_MOVE;
struct S_MOVEDefaultTypeInternal;
extern S_MOVEDefaultTypeInternal _S_MOVE_default_instance_;
class S_QUEST;
struct S_QUESTDefaultTypeInternal;
extern S_QUESTDefaultTypeInternal _S_QUEST_default_instance_;
class S_QUICK_QUEST;
struct S_QUICK_QUESTDefaultTypeInternal;
extern S_QUICK_QUESTDefaultTypeInternal _S_QUICK_QUEST_default_instance_;
class S_REMOVEITEM;
struct S_REMOVEITEMDefaultTypeInternal;
extern S_REMOVEITEMDefaultTypeInternal _S_REMOVEITEM_default_instance_;
class S_SETGOLD;
struct S_SETGOLDDefaultTypeInternal;
extern S_SETGOLDDefaultTypeInternal _S_SETGOLD_default_instance_;
class S_SETITEMCOUNT;
struct S_SETITEMCOUNTDefaultTypeInternal;
extern S_SETITEMCOUNTDefaultTypeInternal _S_SETITEMCOUNT_default_instance_;
class S_SET_DATA;
struct S_SET_DATADefaultTypeInternal;
extern S_SET_DATADefaultTypeInternal _S_SET_DATA_default_instance_;
class S_SPAWN;
struct S_SPAWNDefaultTypeInternal;
extern S_SPAWNDefaultTypeInternal _S_SPAWN_default_instance_;
class S_STATCHANGED;
struct S_STATCHANGEDDefaultTypeInternal;
extern S_STATCHANGEDDefaultTypeInternal _S_STATCHANGED_default_instance_;
class S_UPGRADESKILL;
struct S_UPGRADESKILLDefaultTypeInternal;
extern S_UPGRADESKILLDefaultTypeInternal _S_UPGRADESKILL_default_instance_;
class S_USESKILL;
struct S_USESKILLDefaultTypeInternal;
extern S_USESKILLDefaultTypeInternal _S_USESKILL_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::C_ADDITEM* Arena::CreateMaybeMessage<::Protocol::C_ADDITEM>(Arena*);
template<> ::Protocol::C_ATTACK* Arena::CreateMaybeMessage<::Protocol::C_ATTACK>(Arena*);
template<> ::Protocol::C_CHAT* Arena::CreateMaybeMessage<::Protocol::C_CHAT>(Arena*);
template<> ::Protocol::C_CHECKNAME* Arena::CreateMaybeMessage<::Protocol::C_CHECKNAME>(Arena*);
template<> ::Protocol::C_CREATECHARACTER* Arena::CreateMaybeMessage<::Protocol::C_CREATECHARACTER>(Arena*);
template<> ::Protocol::C_ENTER_GAME* Arena::CreateMaybeMessage<::Protocol::C_ENTER_GAME>(Arena*);
template<> ::Protocol::C_EQUIP* Arena::CreateMaybeMessage<::Protocol::C_EQUIP>(Arena*);
template<> ::Protocol::C_ITEMSWAP* Arena::CreateMaybeMessage<::Protocol::C_ITEMSWAP>(Arena*);
template<> ::Protocol::C_LEAVE_GAME* Arena::CreateMaybeMessage<::Protocol::C_LEAVE_GAME>(Arena*);
template<> ::Protocol::C_LOAD_INFO* Arena::CreateMaybeMessage<::Protocol::C_LOAD_INFO>(Arena*);
template<> ::Protocol::C_LOGIN* Arena::CreateMaybeMessage<::Protocol::C_LOGIN>(Arena*);
template<> ::Protocol::C_MOVE* Arena::CreateMaybeMessage<::Protocol::C_MOVE>(Arena*);
template<> ::Protocol::C_QUEST* Arena::CreateMaybeMessage<::Protocol::C_QUEST>(Arena*);
template<> ::Protocol::C_QUICK_QUEST* Arena::CreateMaybeMessage<::Protocol::C_QUICK_QUEST>(Arena*);
template<> ::Protocol::C_REMOVEITEM* Arena::CreateMaybeMessage<::Protocol::C_REMOVEITEM>(Arena*);
template<> ::Protocol::C_RENEW_TARGET* Arena::CreateMaybeMessage<::Protocol::C_RENEW_TARGET>(Arena*);
template<> ::Protocol::C_SETGOLD* Arena::CreateMaybeMessage<::Protocol::C_SETGOLD>(Arena*);
template<> ::Protocol::C_SET_QUICK* Arena::CreateMaybeMessage<::Protocol::C_SET_QUICK>(Arena*);
template<> ::Protocol::C_UNEQUIP* Arena::CreateMaybeMessage<::Protocol::C_UNEQUIP>(Arena*);
template<> ::Protocol::C_UPGRADESKILL* Arena::CreateMaybeMessage<::Protocol::C_UPGRADESKILL>(Arena*);
template<> ::Protocol::C_USEITEM* Arena::CreateMaybeMessage<::Protocol::C_USEITEM>(Arena*);
template<> ::Protocol::C_USESKILL* Arena::CreateMaybeMessage<::Protocol::C_USESKILL>(Arena*);
template<> ::Protocol::S_ADDITEM* Arena::CreateMaybeMessage<::Protocol::S_ADDITEM>(Arena*);
template<> ::Protocol::S_ATTACK* Arena::CreateMaybeMessage<::Protocol::S_ATTACK>(Arena*);
template<> ::Protocol::S_CHAT* Arena::CreateMaybeMessage<::Protocol::S_CHAT>(Arena*);
template<> ::Protocol::S_CHECKNAME* Arena::CreateMaybeMessage<::Protocol::S_CHECKNAME>(Arena*);
template<> ::Protocol::S_DAMAGED* Arena::CreateMaybeMessage<::Protocol::S_DAMAGED>(Arena*);
template<> ::Protocol::S_DESPAWN* Arena::CreateMaybeMessage<::Protocol::S_DESPAWN>(Arena*);
template<> ::Protocol::S_DIE* Arena::CreateMaybeMessage<::Protocol::S_DIE>(Arena*);
template<> ::Protocol::S_ENTER_GAME* Arena::CreateMaybeMessage<::Protocol::S_ENTER_GAME>(Arena*);
template<> ::Protocol::S_EQUIP* Arena::CreateMaybeMessage<::Protocol::S_EQUIP>(Arena*);
template<> ::Protocol::S_LEAVE_GAME* Arena::CreateMaybeMessage<::Protocol::S_LEAVE_GAME>(Arena*);
template<> ::Protocol::S_LEVEL_UP* Arena::CreateMaybeMessage<::Protocol::S_LEVEL_UP>(Arena*);
template<> ::Protocol::S_LOAD_QUICK* Arena::CreateMaybeMessage<::Protocol::S_LOAD_QUICK>(Arena*);
template<> ::Protocol::S_LOAD_SKILL* Arena::CreateMaybeMessage<::Protocol::S_LOAD_SKILL>(Arena*);
template<> ::Protocol::S_LOAD_TARGET* Arena::CreateMaybeMessage<::Protocol::S_LOAD_TARGET>(Arena*);
template<> ::Protocol::S_LOGIN* Arena::CreateMaybeMessage<::Protocol::S_LOGIN>(Arena*);
template<> ::Protocol::S_MOVE* Arena::CreateMaybeMessage<::Protocol::S_MOVE>(Arena*);
template<> ::Protocol::S_QUEST* Arena::CreateMaybeMessage<::Protocol::S_QUEST>(Arena*);
template<> ::Protocol::S_QUICK_QUEST* Arena::CreateMaybeMessage<::Protocol::S_QUICK_QUEST>(Arena*);
template<> ::Protocol::S_REMOVEITEM* Arena::CreateMaybeMessage<::Protocol::S_REMOVEITEM>(Arena*);
template<> ::Protocol::S_SETGOLD* Arena::CreateMaybeMessage<::Protocol::S_SETGOLD>(Arena*);
template<> ::Protocol::S_SETITEMCOUNT* Arena::CreateMaybeMessage<::Protocol::S_SETITEMCOUNT>(Arena*);
template<> ::Protocol::S_SET_DATA* Arena::CreateMaybeMessage<::Protocol::S_SET_DATA>(Arena*);
template<> ::Protocol::S_SPAWN* Arena::CreateMaybeMessage<::Protocol::S_SPAWN>(Arena*);
template<> ::Protocol::S_STATCHANGED* Arena::CreateMaybeMessage<::Protocol::S_STATCHANGED>(Arena*);
template<> ::Protocol::S_UPGRADESKILL* Arena::CreateMaybeMessage<::Protocol::S_UPGRADESKILL>(Arena*);
template<> ::Protocol::S_USESKILL* Arena::CreateMaybeMessage<::Protocol::S_USESKILL>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

// ===================================================================

class C_LOGIN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_LOGIN) */ {
 public:
  inline C_LOGIN() : C_LOGIN(nullptr) {}
  ~C_LOGIN() override;
  explicit PROTOBUF_CONSTEXPR C_LOGIN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_LOGIN(const C_LOGIN& from);
  C_LOGIN(C_LOGIN&& from) noexcept
    : C_LOGIN() {
    *this = ::std::move(from);
  }

  inline C_LOGIN& operator=(const C_LOGIN& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_LOGIN& operator=(C_LOGIN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_LOGIN& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_LOGIN* internal_default_instance() {
    return reinterpret_cast<const C_LOGIN*>(
               &_C_LOGIN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(C_LOGIN& a, C_LOGIN& b) {
    a.Swap(&b);
  }
  inline void Swap(C_LOGIN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_LOGIN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_LOGIN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_LOGIN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_LOGIN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_LOGIN& from) {
    C_LOGIN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_LOGIN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_LOGIN";
  }
  protected:
  explicit C_LOGIN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_LOGIN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_LOGIN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_LOGIN) */ {
 public:
  inline S_LOGIN() : S_LOGIN(nullptr) {}
  ~S_LOGIN() override;
  explicit PROTOBUF_CONSTEXPR S_LOGIN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LOGIN(const S_LOGIN& from);
  S_LOGIN(S_LOGIN&& from) noexcept
    : S_LOGIN() {
    *this = ::std::move(from);
  }

  inline S_LOGIN& operator=(const S_LOGIN& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LOGIN& operator=(S_LOGIN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LOGIN& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LOGIN* internal_default_instance() {
    return reinterpret_cast<const S_LOGIN*>(
               &_S_LOGIN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(S_LOGIN& a, S_LOGIN& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LOGIN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LOGIN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_LOGIN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_LOGIN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_LOGIN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_LOGIN& from) {
    S_LOGIN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_LOGIN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_LOGIN";
  }
  protected:
  explicit S_LOGIN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCharactersFieldNumber = 2,
    kUserdbidFieldNumber = 1,
  };
  // repeated .Protocol.BaseCharacterInfo characters = 2;
  int characters_size() const;
  private:
  int _internal_characters_size() const;
  public:
  void clear_characters();
  ::Protocol::BaseCharacterInfo* mutable_characters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::BaseCharacterInfo >*
      mutable_characters();
  private:
  const ::Protocol::BaseCharacterInfo& _internal_characters(int index) const;
  ::Protocol::BaseCharacterInfo* _internal_add_characters();
  public:
  const ::Protocol::BaseCharacterInfo& characters(int index) const;
  ::Protocol::BaseCharacterInfo* add_characters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::BaseCharacterInfo >&
      characters() const;

  // uint64 userdbid = 1;
  void clear_userdbid();
  uint64_t userdbid() const;
  void set_userdbid(uint64_t value);
  private:
  uint64_t _internal_userdbid() const;
  void _internal_set_userdbid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_LOGIN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::BaseCharacterInfo > characters_;
    uint64_t userdbid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_CHECKNAME final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_CHECKNAME) */ {
 public:
  inline C_CHECKNAME() : C_CHECKNAME(nullptr) {}
  ~C_CHECKNAME() override;
  explicit PROTOBUF_CONSTEXPR C_CHECKNAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_CHECKNAME(const C_CHECKNAME& from);
  C_CHECKNAME(C_CHECKNAME&& from) noexcept
    : C_CHECKNAME() {
    *this = ::std::move(from);
  }

  inline C_CHECKNAME& operator=(const C_CHECKNAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_CHECKNAME& operator=(C_CHECKNAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_CHECKNAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_CHECKNAME* internal_default_instance() {
    return reinterpret_cast<const C_CHECKNAME*>(
               &_C_CHECKNAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(C_CHECKNAME& a, C_CHECKNAME& b) {
    a.Swap(&b);
  }
  inline void Swap(C_CHECKNAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_CHECKNAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_CHECKNAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_CHECKNAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_CHECKNAME& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_CHECKNAME& from) {
    C_CHECKNAME::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_CHECKNAME* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_CHECKNAME";
  }
  protected:
  explicit C_CHECKNAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_CHECKNAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_CHECKNAME final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_CHECKNAME) */ {
 public:
  inline S_CHECKNAME() : S_CHECKNAME(nullptr) {}
  ~S_CHECKNAME() override;
  explicit PROTOBUF_CONSTEXPR S_CHECKNAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CHECKNAME(const S_CHECKNAME& from);
  S_CHECKNAME(S_CHECKNAME&& from) noexcept
    : S_CHECKNAME() {
    *this = ::std::move(from);
  }

  inline S_CHECKNAME& operator=(const S_CHECKNAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CHECKNAME& operator=(S_CHECKNAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CHECKNAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CHECKNAME* internal_default_instance() {
    return reinterpret_cast<const S_CHECKNAME*>(
               &_S_CHECKNAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(S_CHECKNAME& a, S_CHECKNAME& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CHECKNAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CHECKNAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CHECKNAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CHECKNAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CHECKNAME& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_CHECKNAME& from) {
    S_CHECKNAME::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CHECKNAME* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_CHECKNAME";
  }
  protected:
  explicit S_CHECKNAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDuplicationFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bool duplication = 2;
  void clear_duplication();
  bool duplication() const;
  void set_duplication(bool value);
  private:
  bool _internal_duplication() const;
  void _internal_set_duplication(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_CHECKNAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    bool duplication_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_ENTER_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_ENTER_GAME) */ {
 public:
  inline C_ENTER_GAME() : C_ENTER_GAME(nullptr) {}
  ~C_ENTER_GAME() override;
  explicit PROTOBUF_CONSTEXPR C_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_ENTER_GAME(const C_ENTER_GAME& from);
  C_ENTER_GAME(C_ENTER_GAME&& from) noexcept
    : C_ENTER_GAME() {
    *this = ::std::move(from);
  }

  inline C_ENTER_GAME& operator=(const C_ENTER_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_ENTER_GAME& operator=(C_ENTER_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_ENTER_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_ENTER_GAME* internal_default_instance() {
    return reinterpret_cast<const C_ENTER_GAME*>(
               &_C_ENTER_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(C_ENTER_GAME& a, C_ENTER_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(C_ENTER_GAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_ENTER_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_ENTER_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_ENTER_GAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_ENTER_GAME& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_ENTER_GAME& from) {
    C_ENTER_GAME::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_ENTER_GAME* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_ENTER_GAME";
  }
  protected:
  explicit C_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // uint64 playerId = 1;
  void clear_playerid();
  uint64_t playerid() const;
  void set_playerid(uint64_t value);
  private:
  uint64_t _internal_playerid() const;
  void _internal_set_playerid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_ENTER_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t playerid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_LOAD_INFO final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_LOAD_INFO) */ {
 public:
  inline C_LOAD_INFO() : C_LOAD_INFO(nullptr) {}
  ~C_LOAD_INFO() override;
  explicit PROTOBUF_CONSTEXPR C_LOAD_INFO(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_LOAD_INFO(const C_LOAD_INFO& from);
  C_LOAD_INFO(C_LOAD_INFO&& from) noexcept
    : C_LOAD_INFO() {
    *this = ::std::move(from);
  }

  inline C_LOAD_INFO& operator=(const C_LOAD_INFO& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_LOAD_INFO& operator=(C_LOAD_INFO&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_LOAD_INFO& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_LOAD_INFO* internal_default_instance() {
    return reinterpret_cast<const C_LOAD_INFO*>(
               &_C_LOAD_INFO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(C_LOAD_INFO& a, C_LOAD_INFO& b) {
    a.Swap(&b);
  }
  inline void Swap(C_LOAD_INFO* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_LOAD_INFO* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_LOAD_INFO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_LOAD_INFO>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_LOAD_INFO& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_LOAD_INFO& from) {
    C_LOAD_INFO::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_LOAD_INFO* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_LOAD_INFO";
  }
  protected:
  explicit C_LOAD_INFO(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_LOAD_INFO)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_CREATECHARACTER final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_CREATECHARACTER) */ {
 public:
  inline C_CREATECHARACTER() : C_CREATECHARACTER(nullptr) {}
  ~C_CREATECHARACTER() override;
  explicit PROTOBUF_CONSTEXPR C_CREATECHARACTER(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_CREATECHARACTER(const C_CREATECHARACTER& from);
  C_CREATECHARACTER(C_CREATECHARACTER&& from) noexcept
    : C_CREATECHARACTER() {
    *this = ::std::move(from);
  }

  inline C_CREATECHARACTER& operator=(const C_CREATECHARACTER& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_CREATECHARACTER& operator=(C_CREATECHARACTER&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_CREATECHARACTER& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_CREATECHARACTER* internal_default_instance() {
    return reinterpret_cast<const C_CREATECHARACTER*>(
               &_C_CREATECHARACTER_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(C_CREATECHARACTER& a, C_CREATECHARACTER& b) {
    a.Swap(&b);
  }
  inline void Swap(C_CREATECHARACTER* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_CREATECHARACTER* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_CREATECHARACTER* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_CREATECHARACTER>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_CREATECHARACTER& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_CREATECHARACTER& from) {
    C_CREATECHARACTER::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_CREATECHARACTER* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_CREATECHARACTER";
  }
  protected:
  explicit C_CREATECHARACTER(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kUserIdFieldNumber = 1,
    kTypeFieldNumber = 3,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint64 userId = 1;
  void clear_userid();
  uint64_t userid() const;
  void set_userid(uint64_t value);
  private:
  uint64_t _internal_userid() const;
  void _internal_set_userid(uint64_t value);
  public:

  // .Protocol.ECharacterType type = 3;
  void clear_type();
  ::Protocol::ECharacterType type() const;
  void set_type(::Protocol::ECharacterType value);
  private:
  ::Protocol::ECharacterType _internal_type() const;
  void _internal_set_type(::Protocol::ECharacterType value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_CREATECHARACTER)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint64_t userid_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_ENTER_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ENTER_GAME) */ {
 public:
  inline S_ENTER_GAME() : S_ENTER_GAME(nullptr) {}
  ~S_ENTER_GAME() override;
  explicit PROTOBUF_CONSTEXPR S_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ENTER_GAME(const S_ENTER_GAME& from);
  S_ENTER_GAME(S_ENTER_GAME&& from) noexcept
    : S_ENTER_GAME() {
    *this = ::std::move(from);
  }

  inline S_ENTER_GAME& operator=(const S_ENTER_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ENTER_GAME& operator=(S_ENTER_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ENTER_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ENTER_GAME* internal_default_instance() {
    return reinterpret_cast<const S_ENTER_GAME*>(
               &_S_ENTER_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(S_ENTER_GAME& a, S_ENTER_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ENTER_GAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ENTER_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ENTER_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ENTER_GAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ENTER_GAME& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_ENTER_GAME& from) {
    S_ENTER_GAME::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ENTER_GAME* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ENTER_GAME";
  }
  protected:
  explicit S_ENTER_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerNameFieldNumber = 5,
    kPlayerFieldNumber = 2,
    kStatFieldNumber = 3,
    kSuccessFieldNumber = 1,
    kSkillPointFieldNumber = 4,
  };
  // string playerName = 5;
  void clear_playername();
  const std::string& playername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_playername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_playername();
  PROTOBUF_NODISCARD std::string* release_playername();
  void set_allocated_playername(std::string* playername);
  private:
  const std::string& _internal_playername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_playername(const std::string& value);
  std::string* _internal_mutable_playername();
  public:

  // .Protocol.ObjectInfo player = 2;
  bool has_player() const;
  private:
  bool _internal_has_player() const;
  public:
  void clear_player();
  const ::Protocol::ObjectInfo& player() const;
  PROTOBUF_NODISCARD ::Protocol::ObjectInfo* release_player();
  ::Protocol::ObjectInfo* mutable_player();
  void set_allocated_player(::Protocol::ObjectInfo* player);
  private:
  const ::Protocol::ObjectInfo& _internal_player() const;
  ::Protocol::ObjectInfo* _internal_mutable_player();
  public:
  void unsafe_arena_set_allocated_player(
      ::Protocol::ObjectInfo* player);
  ::Protocol::ObjectInfo* unsafe_arena_release_player();

  // .Protocol.StatInfo stat = 3;
  bool has_stat() const;
  private:
  bool _internal_has_stat() const;
  public:
  void clear_stat();
  const ::Protocol::StatInfo& stat() const;
  PROTOBUF_NODISCARD ::Protocol::StatInfo* release_stat();
  ::Protocol::StatInfo* mutable_stat();
  void set_allocated_stat(::Protocol::StatInfo* stat);
  private:
  const ::Protocol::StatInfo& _internal_stat() const;
  ::Protocol::StatInfo* _internal_mutable_stat();
  public:
  void unsafe_arena_set_allocated_stat(
      ::Protocol::StatInfo* stat);
  ::Protocol::StatInfo* unsafe_arena_release_stat();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // int32 skillPoint = 4;
  void clear_skillpoint();
  int32_t skillpoint() const;
  void set_skillpoint(int32_t value);
  private:
  int32_t _internal_skillpoint() const;
  void _internal_set_skillpoint(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_ENTER_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playername_;
    ::Protocol::ObjectInfo* player_;
    ::Protocol::StatInfo* stat_;
    bool success_;
    int32_t skillpoint_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_LOAD_SKILL final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_LOAD_SKILL) */ {
 public:
  inline S_LOAD_SKILL() : S_LOAD_SKILL(nullptr) {}
  ~S_LOAD_SKILL() override;
  explicit PROTOBUF_CONSTEXPR S_LOAD_SKILL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LOAD_SKILL(const S_LOAD_SKILL& from);
  S_LOAD_SKILL(S_LOAD_SKILL&& from) noexcept
    : S_LOAD_SKILL() {
    *this = ::std::move(from);
  }

  inline S_LOAD_SKILL& operator=(const S_LOAD_SKILL& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LOAD_SKILL& operator=(S_LOAD_SKILL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LOAD_SKILL& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LOAD_SKILL* internal_default_instance() {
    return reinterpret_cast<const S_LOAD_SKILL*>(
               &_S_LOAD_SKILL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(S_LOAD_SKILL& a, S_LOAD_SKILL& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LOAD_SKILL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LOAD_SKILL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_LOAD_SKILL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_LOAD_SKILL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_LOAD_SKILL& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_LOAD_SKILL& from) {
    S_LOAD_SKILL::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_LOAD_SKILL* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_LOAD_SKILL";
  }
  protected:
  explicit S_LOAD_SKILL(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSkillIdsFieldNumber = 1,
    kSkillLevelsFieldNumber = 2,
  };
  // repeated int32 skillIds = 1;
  int skillids_size() const;
  private:
  int _internal_skillids_size() const;
  public:
  void clear_skillids();
  private:
  int32_t _internal_skillids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_skillids() const;
  void _internal_add_skillids(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_skillids();
  public:
  int32_t skillids(int index) const;
  void set_skillids(int index, int32_t value);
  void add_skillids(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      skillids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_skillids();

  // repeated int32 skillLevels = 2;
  int skilllevels_size() const;
  private:
  int _internal_skilllevels_size() const;
  public:
  void clear_skilllevels();
  private:
  int32_t _internal_skilllevels(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_skilllevels() const;
  void _internal_add_skilllevels(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_skilllevels();
  public:
  int32_t skilllevels(int index) const;
  void set_skilllevels(int index, int32_t value);
  void add_skilllevels(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      skilllevels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_skilllevels();

  // @@protoc_insertion_point(class_scope:Protocol.S_LOAD_SKILL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > skillids_;
    mutable std::atomic<int> _skillids_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > skilllevels_;
    mutable std::atomic<int> _skilllevels_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_LOAD_QUICK final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_LOAD_QUICK) */ {
 public:
  inline S_LOAD_QUICK() : S_LOAD_QUICK(nullptr) {}
  ~S_LOAD_QUICK() override;
  explicit PROTOBUF_CONSTEXPR S_LOAD_QUICK(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LOAD_QUICK(const S_LOAD_QUICK& from);
  S_LOAD_QUICK(S_LOAD_QUICK&& from) noexcept
    : S_LOAD_QUICK() {
    *this = ::std::move(from);
  }

  inline S_LOAD_QUICK& operator=(const S_LOAD_QUICK& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LOAD_QUICK& operator=(S_LOAD_QUICK&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LOAD_QUICK& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LOAD_QUICK* internal_default_instance() {
    return reinterpret_cast<const S_LOAD_QUICK*>(
               &_S_LOAD_QUICK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(S_LOAD_QUICK& a, S_LOAD_QUICK& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LOAD_QUICK* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LOAD_QUICK* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_LOAD_QUICK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_LOAD_QUICK>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_LOAD_QUICK& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_LOAD_QUICK& from) {
    S_LOAD_QUICK::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_LOAD_QUICK* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_LOAD_QUICK";
  }
  protected:
  explicit S_LOAD_QUICK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlotFieldNumber = 1,
    kTypeFieldNumber = 2,
    kElementIdFieldNumber = 3,
  };
  // repeated .Protocol.EQuickSlot slot = 1;
  int slot_size() const;
  private:
  int _internal_slot_size() const;
  public:
  void clear_slot();
  private:
  ::Protocol::EQuickSlot _internal_slot(int index) const;
  void _internal_add_slot(::Protocol::EQuickSlot value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_slot();
  public:
  ::Protocol::EQuickSlot slot(int index) const;
  void set_slot(int index, ::Protocol::EQuickSlot value);
  void add_slot(::Protocol::EQuickSlot value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& slot() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_slot();

  // repeated .Protocol.EQuickElementType type = 2;
  int type_size() const;
  private:
  int _internal_type_size() const;
  public:
  void clear_type();
  private:
  ::Protocol::EQuickElementType _internal_type(int index) const;
  void _internal_add_type(::Protocol::EQuickElementType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_type();
  public:
  ::Protocol::EQuickElementType type(int index) const;
  void set_type(int index, ::Protocol::EQuickElementType value);
  void add_type(::Protocol::EQuickElementType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& type() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_type();

  // repeated uint64 elementId = 3;
  int elementid_size() const;
  private:
  int _internal_elementid_size() const;
  public:
  void clear_elementid();
  private:
  uint64_t _internal_elementid(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_elementid() const;
  void _internal_add_elementid(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_elementid();
  public:
  uint64_t elementid(int index) const;
  void set_elementid(int index, uint64_t value);
  void add_elementid(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      elementid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_elementid();

  // @@protoc_insertion_point(class_scope:Protocol.S_LOAD_QUICK)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> slot_;
    mutable std::atomic<int> _slot_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> type_;
    mutable std::atomic<int> _type_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > elementid_;
    mutable std::atomic<int> _elementid_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_LEAVE_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.C_LEAVE_GAME) */ {
 public:
  inline C_LEAVE_GAME() : C_LEAVE_GAME(nullptr) {}
  explicit PROTOBUF_CONSTEXPR C_LEAVE_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_LEAVE_GAME(const C_LEAVE_GAME& from);
  C_LEAVE_GAME(C_LEAVE_GAME&& from) noexcept
    : C_LEAVE_GAME() {
    *this = ::std::move(from);
  }

  inline C_LEAVE_GAME& operator=(const C_LEAVE_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_LEAVE_GAME& operator=(C_LEAVE_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_LEAVE_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_LEAVE_GAME* internal_default_instance() {
    return reinterpret_cast<const C_LEAVE_GAME*>(
               &_C_LEAVE_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(C_LEAVE_GAME& a, C_LEAVE_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(C_LEAVE_GAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_LEAVE_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_LEAVE_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_LEAVE_GAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const C_LEAVE_GAME& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const C_LEAVE_GAME& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_LEAVE_GAME";
  }
  protected:
  explicit C_LEAVE_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.C_LEAVE_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_LEAVE_GAME final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.S_LEAVE_GAME) */ {
 public:
  inline S_LEAVE_GAME() : S_LEAVE_GAME(nullptr) {}
  explicit PROTOBUF_CONSTEXPR S_LEAVE_GAME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LEAVE_GAME(const S_LEAVE_GAME& from);
  S_LEAVE_GAME(S_LEAVE_GAME&& from) noexcept
    : S_LEAVE_GAME() {
    *this = ::std::move(from);
  }

  inline S_LEAVE_GAME& operator=(const S_LEAVE_GAME& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LEAVE_GAME& operator=(S_LEAVE_GAME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LEAVE_GAME& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LEAVE_GAME* internal_default_instance() {
    return reinterpret_cast<const S_LEAVE_GAME*>(
               &_S_LEAVE_GAME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(S_LEAVE_GAME& a, S_LEAVE_GAME& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LEAVE_GAME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LEAVE_GAME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_LEAVE_GAME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_LEAVE_GAME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const S_LEAVE_GAME& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const S_LEAVE_GAME& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_LEAVE_GAME";
  }
  protected:
  explicit S_LEAVE_GAME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.S_LEAVE_GAME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_SPAWN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_SPAWN) */ {
 public:
  inline S_SPAWN() : S_SPAWN(nullptr) {}
  ~S_SPAWN() override;
  explicit PROTOBUF_CONSTEXPR S_SPAWN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_SPAWN(const S_SPAWN& from);
  S_SPAWN(S_SPAWN&& from) noexcept
    : S_SPAWN() {
    *this = ::std::move(from);
  }

  inline S_SPAWN& operator=(const S_SPAWN& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_SPAWN& operator=(S_SPAWN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_SPAWN& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_SPAWN* internal_default_instance() {
    return reinterpret_cast<const S_SPAWN*>(
               &_S_SPAWN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(S_SPAWN& a, S_SPAWN& b) {
    a.Swap(&b);
  }
  inline void Swap(S_SPAWN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_SPAWN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_SPAWN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_SPAWN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_SPAWN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_SPAWN& from) {
    S_SPAWN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_SPAWN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_SPAWN";
  }
  protected:
  explicit S_SPAWN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 1,
    kStatsFieldNumber = 2,
    kPlayerNameFieldNumber = 3,
  };
  // repeated .Protocol.ObjectInfo players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::Protocol::ObjectInfo* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >*
      mutable_players();
  private:
  const ::Protocol::ObjectInfo& _internal_players(int index) const;
  ::Protocol::ObjectInfo* _internal_add_players();
  public:
  const ::Protocol::ObjectInfo& players(int index) const;
  ::Protocol::ObjectInfo* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >&
      players() const;

  // repeated .Protocol.StatInfo stats = 2;
  int stats_size() const;
  private:
  int _internal_stats_size() const;
  public:
  void clear_stats();
  ::Protocol::StatInfo* mutable_stats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::StatInfo >*
      mutable_stats();
  private:
  const ::Protocol::StatInfo& _internal_stats(int index) const;
  ::Protocol::StatInfo* _internal_add_stats();
  public:
  const ::Protocol::StatInfo& stats(int index) const;
  ::Protocol::StatInfo* add_stats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::StatInfo >&
      stats() const;

  // repeated string playerName = 3;
  int playername_size() const;
  private:
  int _internal_playername_size() const;
  public:
  void clear_playername();
  const std::string& playername(int index) const;
  std::string* mutable_playername(int index);
  void set_playername(int index, const std::string& value);
  void set_playername(int index, std::string&& value);
  void set_playername(int index, const char* value);
  void set_playername(int index, const char* value, size_t size);
  std::string* add_playername();
  void add_playername(const std::string& value);
  void add_playername(std::string&& value);
  void add_playername(const char* value);
  void add_playername(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& playername() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_playername();
  private:
  const std::string& _internal_playername(int index) const;
  std::string* _internal_add_playername();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_SPAWN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo > players_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::StatInfo > stats_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> playername_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_DESPAWN final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_DESPAWN) */ {
 public:
  inline S_DESPAWN() : S_DESPAWN(nullptr) {}
  ~S_DESPAWN() override;
  explicit PROTOBUF_CONSTEXPR S_DESPAWN(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_DESPAWN(const S_DESPAWN& from);
  S_DESPAWN(S_DESPAWN&& from) noexcept
    : S_DESPAWN() {
    *this = ::std::move(from);
  }

  inline S_DESPAWN& operator=(const S_DESPAWN& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_DESPAWN& operator=(S_DESPAWN&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_DESPAWN& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_DESPAWN* internal_default_instance() {
    return reinterpret_cast<const S_DESPAWN*>(
               &_S_DESPAWN_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(S_DESPAWN& a, S_DESPAWN& b) {
    a.Swap(&b);
  }
  inline void Swap(S_DESPAWN* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_DESPAWN* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_DESPAWN* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_DESPAWN>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_DESPAWN& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_DESPAWN& from) {
    S_DESPAWN::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_DESPAWN* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_DESPAWN";
  }
  protected:
  explicit S_DESPAWN(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdsFieldNumber = 1,
  };
  // repeated uint64 object_ids = 1;
  int object_ids_size() const;
  private:
  int _internal_object_ids_size() const;
  public:
  void clear_object_ids();
  private:
  uint64_t _internal_object_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_object_ids() const;
  void _internal_add_object_ids(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_object_ids();
  public:
  uint64_t object_ids(int index) const;
  void set_object_ids(int index, uint64_t value);
  void add_object_ids(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      object_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_object_ids();

  // @@protoc_insertion_point(class_scope:Protocol.S_DESPAWN)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > object_ids_;
    mutable std::atomic<int> _object_ids_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_MOVE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_MOVE) */ {
 public:
  inline C_MOVE() : C_MOVE(nullptr) {}
  ~C_MOVE() override;
  explicit PROTOBUF_CONSTEXPR C_MOVE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_MOVE(const C_MOVE& from);
  C_MOVE(C_MOVE&& from) noexcept
    : C_MOVE() {
    *this = ::std::move(from);
  }

  inline C_MOVE& operator=(const C_MOVE& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_MOVE& operator=(C_MOVE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_MOVE& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_MOVE* internal_default_instance() {
    return reinterpret_cast<const C_MOVE*>(
               &_C_MOVE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(C_MOVE& a, C_MOVE& b) {
    a.Swap(&b);
  }
  inline void Swap(C_MOVE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_MOVE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_MOVE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_MOVE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_MOVE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_MOVE& from) {
    C_MOVE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_MOVE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_MOVE";
  }
  protected:
  explicit C_MOVE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
    kPlayerInfoFieldNumber = 2,
  };
  // .Protocol.ObjectInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::Protocol::ObjectInfo& info() const;
  PROTOBUF_NODISCARD ::Protocol::ObjectInfo* release_info();
  ::Protocol::ObjectInfo* mutable_info();
  void set_allocated_info(::Protocol::ObjectInfo* info);
  private:
  const ::Protocol::ObjectInfo& _internal_info() const;
  ::Protocol::ObjectInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::Protocol::ObjectInfo* info);
  ::Protocol::ObjectInfo* unsafe_arena_release_info();

  // .Protocol.PlayerMoveInfo playerInfo = 2;
  bool has_playerinfo() const;
  private:
  bool _internal_has_playerinfo() const;
  public:
  void clear_playerinfo();
  const ::Protocol::PlayerMoveInfo& playerinfo() const;
  PROTOBUF_NODISCARD ::Protocol::PlayerMoveInfo* release_playerinfo();
  ::Protocol::PlayerMoveInfo* mutable_playerinfo();
  void set_allocated_playerinfo(::Protocol::PlayerMoveInfo* playerinfo);
  private:
  const ::Protocol::PlayerMoveInfo& _internal_playerinfo() const;
  ::Protocol::PlayerMoveInfo* _internal_mutable_playerinfo();
  public:
  void unsafe_arena_set_allocated_playerinfo(
      ::Protocol::PlayerMoveInfo* playerinfo);
  ::Protocol::PlayerMoveInfo* unsafe_arena_release_playerinfo();

  // @@protoc_insertion_point(class_scope:Protocol.C_MOVE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::ObjectInfo* info_;
    ::Protocol::PlayerMoveInfo* playerinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_MOVE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_MOVE) */ {
 public:
  inline S_MOVE() : S_MOVE(nullptr) {}
  ~S_MOVE() override;
  explicit PROTOBUF_CONSTEXPR S_MOVE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_MOVE(const S_MOVE& from);
  S_MOVE(S_MOVE&& from) noexcept
    : S_MOVE() {
    *this = ::std::move(from);
  }

  inline S_MOVE& operator=(const S_MOVE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_MOVE& operator=(S_MOVE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_MOVE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_MOVE* internal_default_instance() {
    return reinterpret_cast<const S_MOVE*>(
               &_S_MOVE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(S_MOVE& a, S_MOVE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_MOVE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_MOVE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_MOVE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_MOVE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_MOVE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_MOVE& from) {
    S_MOVE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_MOVE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_MOVE";
  }
  protected:
  explicit S_MOVE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
    kPlayerInfoFieldNumber = 2,
  };
  // .Protocol.ObjectInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::Protocol::ObjectInfo& info() const;
  PROTOBUF_NODISCARD ::Protocol::ObjectInfo* release_info();
  ::Protocol::ObjectInfo* mutable_info();
  void set_allocated_info(::Protocol::ObjectInfo* info);
  private:
  const ::Protocol::ObjectInfo& _internal_info() const;
  ::Protocol::ObjectInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::Protocol::ObjectInfo* info);
  ::Protocol::ObjectInfo* unsafe_arena_release_info();

  // .Protocol.PlayerMoveInfo playerInfo = 2;
  bool has_playerinfo() const;
  private:
  bool _internal_has_playerinfo() const;
  public:
  void clear_playerinfo();
  const ::Protocol::PlayerMoveInfo& playerinfo() const;
  PROTOBUF_NODISCARD ::Protocol::PlayerMoveInfo* release_playerinfo();
  ::Protocol::PlayerMoveInfo* mutable_playerinfo();
  void set_allocated_playerinfo(::Protocol::PlayerMoveInfo* playerinfo);
  private:
  const ::Protocol::PlayerMoveInfo& _internal_playerinfo() const;
  ::Protocol::PlayerMoveInfo* _internal_mutable_playerinfo();
  public:
  void unsafe_arena_set_allocated_playerinfo(
      ::Protocol::PlayerMoveInfo* playerinfo);
  ::Protocol::PlayerMoveInfo* unsafe_arena_release_playerinfo();

  // @@protoc_insertion_point(class_scope:Protocol.S_MOVE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::ObjectInfo* info_;
    ::Protocol::PlayerMoveInfo* playerinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_ATTACK final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_ATTACK) */ {
 public:
  inline C_ATTACK() : C_ATTACK(nullptr) {}
  ~C_ATTACK() override;
  explicit PROTOBUF_CONSTEXPR C_ATTACK(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_ATTACK(const C_ATTACK& from);
  C_ATTACK(C_ATTACK&& from) noexcept
    : C_ATTACK() {
    *this = ::std::move(from);
  }

  inline C_ATTACK& operator=(const C_ATTACK& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_ATTACK& operator=(C_ATTACK&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_ATTACK& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_ATTACK* internal_default_instance() {
    return reinterpret_cast<const C_ATTACK*>(
               &_C_ATTACK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(C_ATTACK& a, C_ATTACK& b) {
    a.Swap(&b);
  }
  inline void Swap(C_ATTACK* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_ATTACK* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_ATTACK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_ATTACK>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_ATTACK& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_ATTACK& from) {
    C_ATTACK::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_ATTACK* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_ATTACK";
  }
  protected:
  explicit C_ATTACK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
    kAttackSequenceFieldNumber = 2,
    kXFieldNumber = 3,
    kYFieldNumber = 4,
    kZFieldNumber = 5,
  };
  // .Protocol.ObjectInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::Protocol::ObjectInfo& info() const;
  PROTOBUF_NODISCARD ::Protocol::ObjectInfo* release_info();
  ::Protocol::ObjectInfo* mutable_info();
  void set_allocated_info(::Protocol::ObjectInfo* info);
  private:
  const ::Protocol::ObjectInfo& _internal_info() const;
  ::Protocol::ObjectInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::Protocol::ObjectInfo* info);
  ::Protocol::ObjectInfo* unsafe_arena_release_info();

  // int32 attack_sequence = 2;
  void clear_attack_sequence();
  int32_t attack_sequence() const;
  void set_attack_sequence(int32_t value);
  private:
  int32_t _internal_attack_sequence() const;
  void _internal_set_attack_sequence(int32_t value);
  public:

  // float x = 3;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 4;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 5;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_ATTACK)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::ObjectInfo* info_;
    int32_t attack_sequence_;
    float x_;
    float y_;
    float z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_ATTACK final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ATTACK) */ {
 public:
  inline S_ATTACK() : S_ATTACK(nullptr) {}
  ~S_ATTACK() override;
  explicit PROTOBUF_CONSTEXPR S_ATTACK(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ATTACK(const S_ATTACK& from);
  S_ATTACK(S_ATTACK&& from) noexcept
    : S_ATTACK() {
    *this = ::std::move(from);
  }

  inline S_ATTACK& operator=(const S_ATTACK& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ATTACK& operator=(S_ATTACK&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ATTACK& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ATTACK* internal_default_instance() {
    return reinterpret_cast<const S_ATTACK*>(
               &_S_ATTACK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(S_ATTACK& a, S_ATTACK& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ATTACK* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ATTACK* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ATTACK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ATTACK>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ATTACK& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_ATTACK& from) {
    S_ATTACK::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ATTACK* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ATTACK";
  }
  protected:
  explicit S_ATTACK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
    kAttackSequenceFieldNumber = 2,
    kXFieldNumber = 3,
    kYFieldNumber = 4,
    kZFieldNumber = 5,
  };
  // .Protocol.ObjectInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::Protocol::ObjectInfo& info() const;
  PROTOBUF_NODISCARD ::Protocol::ObjectInfo* release_info();
  ::Protocol::ObjectInfo* mutable_info();
  void set_allocated_info(::Protocol::ObjectInfo* info);
  private:
  const ::Protocol::ObjectInfo& _internal_info() const;
  ::Protocol::ObjectInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::Protocol::ObjectInfo* info);
  ::Protocol::ObjectInfo* unsafe_arena_release_info();

  // int32 attack_sequence = 2;
  void clear_attack_sequence();
  int32_t attack_sequence() const;
  void set_attack_sequence(int32_t value);
  private:
  int32_t _internal_attack_sequence() const;
  void _internal_set_attack_sequence(int32_t value);
  public:

  // float x = 3;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 4;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 5;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_ATTACK)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::ObjectInfo* info_;
    int32_t attack_sequence_;
    float x_;
    float y_;
    float z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_USESKILL final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_USESKILL) */ {
 public:
  inline C_USESKILL() : C_USESKILL(nullptr) {}
  ~C_USESKILL() override;
  explicit PROTOBUF_CONSTEXPR C_USESKILL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_USESKILL(const C_USESKILL& from);
  C_USESKILL(C_USESKILL&& from) noexcept
    : C_USESKILL() {
    *this = ::std::move(from);
  }

  inline C_USESKILL& operator=(const C_USESKILL& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_USESKILL& operator=(C_USESKILL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_USESKILL& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_USESKILL* internal_default_instance() {
    return reinterpret_cast<const C_USESKILL*>(
               &_C_USESKILL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(C_USESKILL& a, C_USESKILL& b) {
    a.Swap(&b);
  }
  inline void Swap(C_USESKILL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_USESKILL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_USESKILL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_USESKILL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_USESKILL& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_USESKILL& from) {
    C_USESKILL::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_USESKILL* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_USESKILL";
  }
  protected:
  explicit C_USESKILL(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
    kSkillIdFieldNumber = 2,
    kXFieldNumber = 3,
    kYFieldNumber = 4,
    kZFieldNumber = 5,
  };
  // .Protocol.ObjectInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::Protocol::ObjectInfo& info() const;
  PROTOBUF_NODISCARD ::Protocol::ObjectInfo* release_info();
  ::Protocol::ObjectInfo* mutable_info();
  void set_allocated_info(::Protocol::ObjectInfo* info);
  private:
  const ::Protocol::ObjectInfo& _internal_info() const;
  ::Protocol::ObjectInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::Protocol::ObjectInfo* info);
  ::Protocol::ObjectInfo* unsafe_arena_release_info();

  // int32 SkillId = 2;
  void clear_skillid();
  int32_t skillid() const;
  void set_skillid(int32_t value);
  private:
  int32_t _internal_skillid() const;
  void _internal_set_skillid(int32_t value);
  public:

  // float x = 3;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 4;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 5;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_USESKILL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::ObjectInfo* info_;
    int32_t skillid_;
    float x_;
    float y_;
    float z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_USESKILL final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_USESKILL) */ {
 public:
  inline S_USESKILL() : S_USESKILL(nullptr) {}
  ~S_USESKILL() override;
  explicit PROTOBUF_CONSTEXPR S_USESKILL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_USESKILL(const S_USESKILL& from);
  S_USESKILL(S_USESKILL&& from) noexcept
    : S_USESKILL() {
    *this = ::std::move(from);
  }

  inline S_USESKILL& operator=(const S_USESKILL& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_USESKILL& operator=(S_USESKILL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_USESKILL& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_USESKILL* internal_default_instance() {
    return reinterpret_cast<const S_USESKILL*>(
               &_S_USESKILL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(S_USESKILL& a, S_USESKILL& b) {
    a.Swap(&b);
  }
  inline void Swap(S_USESKILL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_USESKILL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_USESKILL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_USESKILL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_USESKILL& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_USESKILL& from) {
    S_USESKILL::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_USESKILL* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_USESKILL";
  }
  protected:
  explicit S_USESKILL(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
    kSkillIdFieldNumber = 2,
    kXFieldNumber = 3,
    kYFieldNumber = 4,
    kZFieldNumber = 5,
    kCoolDownFieldNumber = 6,
  };
  // .Protocol.ObjectInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::Protocol::ObjectInfo& info() const;
  PROTOBUF_NODISCARD ::Protocol::ObjectInfo* release_info();
  ::Protocol::ObjectInfo* mutable_info();
  void set_allocated_info(::Protocol::ObjectInfo* info);
  private:
  const ::Protocol::ObjectInfo& _internal_info() const;
  ::Protocol::ObjectInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::Protocol::ObjectInfo* info);
  ::Protocol::ObjectInfo* unsafe_arena_release_info();

  // int32 SkillId = 2;
  void clear_skillid();
  int32_t skillid() const;
  void set_skillid(int32_t value);
  private:
  int32_t _internal_skillid() const;
  void _internal_set_skillid(int32_t value);
  public:

  // float x = 3;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 4;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 5;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // int32 coolDown = 6;
  void clear_cooldown();
  int32_t cooldown() const;
  void set_cooldown(int32_t value);
  private:
  int32_t _internal_cooldown() const;
  void _internal_set_cooldown(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_USESKILL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::ObjectInfo* info_;
    int32_t skillid_;
    float x_;
    float y_;
    float z_;
    int32_t cooldown_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_DAMAGED final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_DAMAGED) */ {
 public:
  inline S_DAMAGED() : S_DAMAGED(nullptr) {}
  ~S_DAMAGED() override;
  explicit PROTOBUF_CONSTEXPR S_DAMAGED(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_DAMAGED(const S_DAMAGED& from);
  S_DAMAGED(S_DAMAGED&& from) noexcept
    : S_DAMAGED() {
    *this = ::std::move(from);
  }

  inline S_DAMAGED& operator=(const S_DAMAGED& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_DAMAGED& operator=(S_DAMAGED&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_DAMAGED& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_DAMAGED* internal_default_instance() {
    return reinterpret_cast<const S_DAMAGED*>(
               &_S_DAMAGED_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(S_DAMAGED& a, S_DAMAGED& b) {
    a.Swap(&b);
  }
  inline void Swap(S_DAMAGED* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_DAMAGED* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_DAMAGED* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_DAMAGED>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_DAMAGED& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_DAMAGED& from) {
    S_DAMAGED::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_DAMAGED* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_DAMAGED";
  }
  protected:
  explicit S_DAMAGED(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
    kAttackerIdFieldNumber = 3,
    kDamageFieldNumber = 2,
  };
  // .Protocol.ObjectInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::Protocol::ObjectInfo& info() const;
  PROTOBUF_NODISCARD ::Protocol::ObjectInfo* release_info();
  ::Protocol::ObjectInfo* mutable_info();
  void set_allocated_info(::Protocol::ObjectInfo* info);
  private:
  const ::Protocol::ObjectInfo& _internal_info() const;
  ::Protocol::ObjectInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::Protocol::ObjectInfo* info);
  ::Protocol::ObjectInfo* unsafe_arena_release_info();

  // uint64 attackerId = 3;
  void clear_attackerid();
  uint64_t attackerid() const;
  void set_attackerid(uint64_t value);
  private:
  uint64_t _internal_attackerid() const;
  void _internal_set_attackerid(uint64_t value);
  public:

  // int32 damage = 2;
  void clear_damage();
  int32_t damage() const;
  void set_damage(int32_t value);
  private:
  int32_t _internal_damage() const;
  void _internal_set_damage(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_DAMAGED)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::ObjectInfo* info_;
    uint64_t attackerid_;
    int32_t damage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_DIE final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_DIE) */ {
 public:
  inline S_DIE() : S_DIE(nullptr) {}
  ~S_DIE() override;
  explicit PROTOBUF_CONSTEXPR S_DIE(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_DIE(const S_DIE& from);
  S_DIE(S_DIE&& from) noexcept
    : S_DIE() {
    *this = ::std::move(from);
  }

  inline S_DIE& operator=(const S_DIE& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_DIE& operator=(S_DIE&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_DIE& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_DIE* internal_default_instance() {
    return reinterpret_cast<const S_DIE*>(
               &_S_DIE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(S_DIE& a, S_DIE& b) {
    a.Swap(&b);
  }
  inline void Swap(S_DIE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_DIE* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_DIE* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_DIE>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_DIE& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_DIE& from) {
    S_DIE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_DIE* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_DIE";
  }
  protected:
  explicit S_DIE(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // .Protocol.ObjectInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::Protocol::ObjectInfo& info() const;
  PROTOBUF_NODISCARD ::Protocol::ObjectInfo* release_info();
  ::Protocol::ObjectInfo* mutable_info();
  void set_allocated_info(::Protocol::ObjectInfo* info);
  private:
  const ::Protocol::ObjectInfo& _internal_info() const;
  ::Protocol::ObjectInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::Protocol::ObjectInfo* info);
  ::Protocol::ObjectInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:Protocol.S_DIE)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::ObjectInfo* info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_CHAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_CHAT) */ {
 public:
  inline C_CHAT() : C_CHAT(nullptr) {}
  ~C_CHAT() override;
  explicit PROTOBUF_CONSTEXPR C_CHAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_CHAT(const C_CHAT& from);
  C_CHAT(C_CHAT&& from) noexcept
    : C_CHAT() {
    *this = ::std::move(from);
  }

  inline C_CHAT& operator=(const C_CHAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_CHAT& operator=(C_CHAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_CHAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_CHAT* internal_default_instance() {
    return reinterpret_cast<const C_CHAT*>(
               &_C_CHAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(C_CHAT& a, C_CHAT& b) {
    a.Swap(&b);
  }
  inline void Swap(C_CHAT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_CHAT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_CHAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_CHAT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_CHAT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_CHAT& from) {
    C_CHAT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_CHAT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_CHAT";
  }
  protected:
  explicit C_CHAT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
  };
  // string msg = 1;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_CHAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_CHAT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_CHAT) */ {
 public:
  inline S_CHAT() : S_CHAT(nullptr) {}
  ~S_CHAT() override;
  explicit PROTOBUF_CONSTEXPR S_CHAT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CHAT(const S_CHAT& from);
  S_CHAT(S_CHAT&& from) noexcept
    : S_CHAT() {
    *this = ::std::move(from);
  }

  inline S_CHAT& operator=(const S_CHAT& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CHAT& operator=(S_CHAT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CHAT& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CHAT* internal_default_instance() {
    return reinterpret_cast<const S_CHAT*>(
               &_S_CHAT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(S_CHAT& a, S_CHAT& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CHAT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CHAT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CHAT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CHAT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CHAT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_CHAT& from) {
    S_CHAT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CHAT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_CHAT";
  }
  protected:
  explicit S_CHAT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kPlayerIdFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // uint64 playerId = 1;
  void clear_playerid();
  uint64_t playerid() const;
  void set_playerid(uint64_t value);
  private:
  uint64_t _internal_playerid() const;
  void _internal_set_playerid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_CHAT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    uint64_t playerid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_SETGOLD final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_SETGOLD) */ {
 public:
  inline C_SETGOLD() : C_SETGOLD(nullptr) {}
  ~C_SETGOLD() override;
  explicit PROTOBUF_CONSTEXPR C_SETGOLD(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_SETGOLD(const C_SETGOLD& from);
  C_SETGOLD(C_SETGOLD&& from) noexcept
    : C_SETGOLD() {
    *this = ::std::move(from);
  }

  inline C_SETGOLD& operator=(const C_SETGOLD& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_SETGOLD& operator=(C_SETGOLD&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_SETGOLD& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_SETGOLD* internal_default_instance() {
    return reinterpret_cast<const C_SETGOLD*>(
               &_C_SETGOLD_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(C_SETGOLD& a, C_SETGOLD& b) {
    a.Swap(&b);
  }
  inline void Swap(C_SETGOLD* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_SETGOLD* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_SETGOLD* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_SETGOLD>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_SETGOLD& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_SETGOLD& from) {
    C_SETGOLD::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_SETGOLD* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_SETGOLD";
  }
  protected:
  explicit C_SETGOLD(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kGoldFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // int32 gold = 2;
  void clear_gold();
  int32_t gold() const;
  void set_gold(int32_t value);
  private:
  int32_t _internal_gold() const;
  void _internal_set_gold(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_SETGOLD)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    int32_t gold_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_SETGOLD final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_SETGOLD) */ {
 public:
  inline S_SETGOLD() : S_SETGOLD(nullptr) {}
  ~S_SETGOLD() override;
  explicit PROTOBUF_CONSTEXPR S_SETGOLD(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_SETGOLD(const S_SETGOLD& from);
  S_SETGOLD(S_SETGOLD&& from) noexcept
    : S_SETGOLD() {
    *this = ::std::move(from);
  }

  inline S_SETGOLD& operator=(const S_SETGOLD& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_SETGOLD& operator=(S_SETGOLD&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_SETGOLD& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_SETGOLD* internal_default_instance() {
    return reinterpret_cast<const S_SETGOLD*>(
               &_S_SETGOLD_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(S_SETGOLD& a, S_SETGOLD& b) {
    a.Swap(&b);
  }
  inline void Swap(S_SETGOLD* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_SETGOLD* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_SETGOLD* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_SETGOLD>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_SETGOLD& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_SETGOLD& from) {
    S_SETGOLD::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_SETGOLD* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_SETGOLD";
  }
  protected:
  explicit S_SETGOLD(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kGoldFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // int32 gold = 2;
  void clear_gold();
  int32_t gold() const;
  void set_gold(int32_t value);
  private:
  int32_t _internal_gold() const;
  void _internal_set_gold(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_SETGOLD)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    int32_t gold_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_ADDITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_ADDITEM) */ {
 public:
  inline C_ADDITEM() : C_ADDITEM(nullptr) {}
  ~C_ADDITEM() override;
  explicit PROTOBUF_CONSTEXPR C_ADDITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_ADDITEM(const C_ADDITEM& from);
  C_ADDITEM(C_ADDITEM&& from) noexcept
    : C_ADDITEM() {
    *this = ::std::move(from);
  }

  inline C_ADDITEM& operator=(const C_ADDITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_ADDITEM& operator=(C_ADDITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_ADDITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_ADDITEM* internal_default_instance() {
    return reinterpret_cast<const C_ADDITEM*>(
               &_C_ADDITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(C_ADDITEM& a, C_ADDITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(C_ADDITEM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_ADDITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_ADDITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_ADDITEM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_ADDITEM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_ADDITEM& from) {
    C_ADDITEM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_ADDITEM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_ADDITEM";
  }
  protected:
  explicit C_ADDITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTemplateIdFieldNumber = 1,
    kItemTypeFieldNumber = 2,
    kGetTypeFieldNumber = 3,
    kCountFieldNumber = 4,
  };
  // uint32 templateId = 1;
  void clear_templateid();
  uint32_t templateid() const;
  void set_templateid(uint32_t value);
  private:
  uint32_t _internal_templateid() const;
  void _internal_set_templateid(uint32_t value);
  public:

  // .Protocol.EItemType itemType = 2;
  void clear_itemtype();
  ::Protocol::EItemType itemtype() const;
  void set_itemtype(::Protocol::EItemType value);
  private:
  ::Protocol::EItemType _internal_itemtype() const;
  void _internal_set_itemtype(::Protocol::EItemType value);
  public:

  // .Protocol.EGetItemType getType = 3;
  void clear_gettype();
  ::Protocol::EGetItemType gettype() const;
  void set_gettype(::Protocol::EGetItemType value);
  private:
  ::Protocol::EGetItemType _internal_gettype() const;
  void _internal_set_gettype(::Protocol::EGetItemType value);
  public:

  // int32 count = 4;
  void clear_count();
  int32_t count() const;
  void set_count(int32_t value);
  private:
  int32_t _internal_count() const;
  void _internal_set_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_ADDITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t templateid_;
    int itemtype_;
    int gettype_;
    int32_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_ADDITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_ADDITEM) */ {
 public:
  inline S_ADDITEM() : S_ADDITEM(nullptr) {}
  ~S_ADDITEM() override;
  explicit PROTOBUF_CONSTEXPR S_ADDITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ADDITEM(const S_ADDITEM& from);
  S_ADDITEM(S_ADDITEM&& from) noexcept
    : S_ADDITEM() {
    *this = ::std::move(from);
  }

  inline S_ADDITEM& operator=(const S_ADDITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ADDITEM& operator=(S_ADDITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ADDITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ADDITEM* internal_default_instance() {
    return reinterpret_cast<const S_ADDITEM*>(
               &_S_ADDITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(S_ADDITEM& a, S_ADDITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ADDITEM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ADDITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ADDITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ADDITEM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ADDITEM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_ADDITEM& from) {
    S_ADDITEM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ADDITEM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_ADDITEM";
  }
  protected:
  explicit S_ADDITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
    kByUnequipFieldNumber = 2,
  };
  // .Protocol.ItemUpdateInfo item = 1;
  bool has_item() const;
  private:
  bool _internal_has_item() const;
  public:
  void clear_item();
  const ::Protocol::ItemUpdateInfo& item() const;
  PROTOBUF_NODISCARD ::Protocol::ItemUpdateInfo* release_item();
  ::Protocol::ItemUpdateInfo* mutable_item();
  void set_allocated_item(::Protocol::ItemUpdateInfo* item);
  private:
  const ::Protocol::ItemUpdateInfo& _internal_item() const;
  ::Protocol::ItemUpdateInfo* _internal_mutable_item();
  public:
  void unsafe_arena_set_allocated_item(
      ::Protocol::ItemUpdateInfo* item);
  ::Protocol::ItemUpdateInfo* unsafe_arena_release_item();

  // bool byUnequip = 2;
  void clear_byunequip();
  bool byunequip() const;
  void set_byunequip(bool value);
  private:
  bool _internal_byunequip() const;
  void _internal_set_byunequip(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_ADDITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::ItemUpdateInfo* item_;
    bool byunequip_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_ITEMSWAP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_ITEMSWAP) */ {
 public:
  inline C_ITEMSWAP() : C_ITEMSWAP(nullptr) {}
  ~C_ITEMSWAP() override;
  explicit PROTOBUF_CONSTEXPR C_ITEMSWAP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_ITEMSWAP(const C_ITEMSWAP& from);
  C_ITEMSWAP(C_ITEMSWAP&& from) noexcept
    : C_ITEMSWAP() {
    *this = ::std::move(from);
  }

  inline C_ITEMSWAP& operator=(const C_ITEMSWAP& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_ITEMSWAP& operator=(C_ITEMSWAP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_ITEMSWAP& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_ITEMSWAP* internal_default_instance() {
    return reinterpret_cast<const C_ITEMSWAP*>(
               &_C_ITEMSWAP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(C_ITEMSWAP& a, C_ITEMSWAP& b) {
    a.Swap(&b);
  }
  inline void Swap(C_ITEMSWAP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_ITEMSWAP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_ITEMSWAP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_ITEMSWAP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_ITEMSWAP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_ITEMSWAP& from) {
    C_ITEMSWAP::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_ITEMSWAP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_ITEMSWAP";
  }
  protected:
  explicit C_ITEMSWAP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kItem1DbIdFieldNumber = 2,
    kItem2DbIdFieldNumber = 4,
    kItem1SlotFieldNumber = 3,
    kItem2SlotFieldNumber = 5,
  };
  // uint64 playerId = 1;
  void clear_playerid();
  uint64_t playerid() const;
  void set_playerid(uint64_t value);
  private:
  uint64_t _internal_playerid() const;
  void _internal_set_playerid(uint64_t value);
  public:

  // uint64 item1_dbId = 2;
  void clear_item1_dbid();
  uint64_t item1_dbid() const;
  void set_item1_dbid(uint64_t value);
  private:
  uint64_t _internal_item1_dbid() const;
  void _internal_set_item1_dbid(uint64_t value);
  public:

  // uint64 item2_dbId = 4;
  void clear_item2_dbid();
  uint64_t item2_dbid() const;
  void set_item2_dbid(uint64_t value);
  private:
  uint64_t _internal_item2_dbid() const;
  void _internal_set_item2_dbid(uint64_t value);
  public:

  // int32 item1_slot = 3;
  void clear_item1_slot();
  int32_t item1_slot() const;
  void set_item1_slot(int32_t value);
  private:
  int32_t _internal_item1_slot() const;
  void _internal_set_item1_slot(int32_t value);
  public:

  // int32 item2_slot = 5;
  void clear_item2_slot();
  int32_t item2_slot() const;
  void set_item2_slot(int32_t value);
  private:
  int32_t _internal_item2_slot() const;
  void _internal_set_item2_slot(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_ITEMSWAP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t playerid_;
    uint64_t item1_dbid_;
    uint64_t item2_dbid_;
    int32_t item1_slot_;
    int32_t item2_slot_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_SET_QUICK final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_SET_QUICK) */ {
 public:
  inline C_SET_QUICK() : C_SET_QUICK(nullptr) {}
  ~C_SET_QUICK() override;
  explicit PROTOBUF_CONSTEXPR C_SET_QUICK(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_SET_QUICK(const C_SET_QUICK& from);
  C_SET_QUICK(C_SET_QUICK&& from) noexcept
    : C_SET_QUICK() {
    *this = ::std::move(from);
  }

  inline C_SET_QUICK& operator=(const C_SET_QUICK& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_SET_QUICK& operator=(C_SET_QUICK&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_SET_QUICK& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_SET_QUICK* internal_default_instance() {
    return reinterpret_cast<const C_SET_QUICK*>(
               &_C_SET_QUICK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(C_SET_QUICK& a, C_SET_QUICK& b) {
    a.Swap(&b);
  }
  inline void Swap(C_SET_QUICK* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_SET_QUICK* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_SET_QUICK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_SET_QUICK>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_SET_QUICK& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_SET_QUICK& from) {
    C_SET_QUICK::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_SET_QUICK* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_SET_QUICK";
  }
  protected:
  explicit C_SET_QUICK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kElementIdFieldNumber = 2,
    kTypeFieldNumber = 1,
    kSlotFieldNumber = 3,
  };
  // uint64 elementId = 2;
  void clear_elementid();
  uint64_t elementid() const;
  void set_elementid(uint64_t value);
  private:
  uint64_t _internal_elementid() const;
  void _internal_set_elementid(uint64_t value);
  public:

  // .Protocol.EQuickElementType type = 1;
  void clear_type();
  ::Protocol::EQuickElementType type() const;
  void set_type(::Protocol::EQuickElementType value);
  private:
  ::Protocol::EQuickElementType _internal_type() const;
  void _internal_set_type(::Protocol::EQuickElementType value);
  public:

  // .Protocol.EQuickSlot slot = 3;
  void clear_slot();
  ::Protocol::EQuickSlot slot() const;
  void set_slot(::Protocol::EQuickSlot value);
  private:
  ::Protocol::EQuickSlot _internal_slot() const;
  void _internal_set_slot(::Protocol::EQuickSlot value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_SET_QUICK)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t elementid_;
    int type_;
    int slot_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_EQUIP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_EQUIP) */ {
 public:
  inline C_EQUIP() : C_EQUIP(nullptr) {}
  ~C_EQUIP() override;
  explicit PROTOBUF_CONSTEXPR C_EQUIP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_EQUIP(const C_EQUIP& from);
  C_EQUIP(C_EQUIP&& from) noexcept
    : C_EQUIP() {
    *this = ::std::move(from);
  }

  inline C_EQUIP& operator=(const C_EQUIP& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_EQUIP& operator=(C_EQUIP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_EQUIP& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_EQUIP* internal_default_instance() {
    return reinterpret_cast<const C_EQUIP*>(
               &_C_EQUIP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(C_EQUIP& a, C_EQUIP& b) {
    a.Swap(&b);
  }
  inline void Swap(C_EQUIP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_EQUIP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_EQUIP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_EQUIP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_EQUIP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_EQUIP& from) {
    C_EQUIP::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_EQUIP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_EQUIP";
  }
  protected:
  explicit C_EQUIP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
  };
  // uint64 itemId = 1;
  void clear_itemid();
  uint64_t itemid() const;
  void set_itemid(uint64_t value);
  private:
  uint64_t _internal_itemid() const;
  void _internal_set_itemid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_EQUIP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t itemid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_EQUIP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_EQUIP) */ {
 public:
  inline S_EQUIP() : S_EQUIP(nullptr) {}
  ~S_EQUIP() override;
  explicit PROTOBUF_CONSTEXPR S_EQUIP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_EQUIP(const S_EQUIP& from);
  S_EQUIP(S_EQUIP&& from) noexcept
    : S_EQUIP() {
    *this = ::std::move(from);
  }

  inline S_EQUIP& operator=(const S_EQUIP& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_EQUIP& operator=(S_EQUIP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_EQUIP& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_EQUIP* internal_default_instance() {
    return reinterpret_cast<const S_EQUIP*>(
               &_S_EQUIP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(S_EQUIP& a, S_EQUIP& b) {
    a.Swap(&b);
  }
  inline void Swap(S_EQUIP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_EQUIP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_EQUIP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_EQUIP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_EQUIP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_EQUIP& from) {
    S_EQUIP::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_EQUIP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_EQUIP";
  }
  protected:
  explicit S_EQUIP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEquipDbIdFieldNumber = 1,
    kPrevItemDbIdFieldNumber = 2,
    kPrevItemSlotIndexFieldNumber = 3,
  };
  // uint64 equipDbId = 1;
  void clear_equipdbid();
  uint64_t equipdbid() const;
  void set_equipdbid(uint64_t value);
  private:
  uint64_t _internal_equipdbid() const;
  void _internal_set_equipdbid(uint64_t value);
  public:

  // uint64 prevItemDbId = 2;
  void clear_previtemdbid();
  uint64_t previtemdbid() const;
  void set_previtemdbid(uint64_t value);
  private:
  uint64_t _internal_previtemdbid() const;
  void _internal_set_previtemdbid(uint64_t value);
  public:

  // int32 prevItemSlotIndex = 3;
  void clear_previtemslotindex();
  int32_t previtemslotindex() const;
  void set_previtemslotindex(int32_t value);
  private:
  int32_t _internal_previtemslotindex() const;
  void _internal_set_previtemslotindex(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_EQUIP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t equipdbid_;
    uint64_t previtemdbid_;
    int32_t previtemslotindex_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_UNEQUIP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_UNEQUIP) */ {
 public:
  inline C_UNEQUIP() : C_UNEQUIP(nullptr) {}
  ~C_UNEQUIP() override;
  explicit PROTOBUF_CONSTEXPR C_UNEQUIP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_UNEQUIP(const C_UNEQUIP& from);
  C_UNEQUIP(C_UNEQUIP&& from) noexcept
    : C_UNEQUIP() {
    *this = ::std::move(from);
  }

  inline C_UNEQUIP& operator=(const C_UNEQUIP& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_UNEQUIP& operator=(C_UNEQUIP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_UNEQUIP& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_UNEQUIP* internal_default_instance() {
    return reinterpret_cast<const C_UNEQUIP*>(
               &_C_UNEQUIP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(C_UNEQUIP& a, C_UNEQUIP& b) {
    a.Swap(&b);
  }
  inline void Swap(C_UNEQUIP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_UNEQUIP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_UNEQUIP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_UNEQUIP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_UNEQUIP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_UNEQUIP& from) {
    C_UNEQUIP::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_UNEQUIP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_UNEQUIP";
  }
  protected:
  explicit C_UNEQUIP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
  };
  // uint64 itemId = 1;
  void clear_itemid();
  uint64_t itemid() const;
  void set_itemid(uint64_t value);
  private:
  uint64_t _internal_itemid() const;
  void _internal_set_itemid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_UNEQUIP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t itemid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_SETITEMCOUNT final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_SETITEMCOUNT) */ {
 public:
  inline S_SETITEMCOUNT() : S_SETITEMCOUNT(nullptr) {}
  ~S_SETITEMCOUNT() override;
  explicit PROTOBUF_CONSTEXPR S_SETITEMCOUNT(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_SETITEMCOUNT(const S_SETITEMCOUNT& from);
  S_SETITEMCOUNT(S_SETITEMCOUNT&& from) noexcept
    : S_SETITEMCOUNT() {
    *this = ::std::move(from);
  }

  inline S_SETITEMCOUNT& operator=(const S_SETITEMCOUNT& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_SETITEMCOUNT& operator=(S_SETITEMCOUNT&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_SETITEMCOUNT& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_SETITEMCOUNT* internal_default_instance() {
    return reinterpret_cast<const S_SETITEMCOUNT*>(
               &_S_SETITEMCOUNT_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(S_SETITEMCOUNT& a, S_SETITEMCOUNT& b) {
    a.Swap(&b);
  }
  inline void Swap(S_SETITEMCOUNT* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_SETITEMCOUNT* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_SETITEMCOUNT* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_SETITEMCOUNT>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_SETITEMCOUNT& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_SETITEMCOUNT& from) {
    S_SETITEMCOUNT::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_SETITEMCOUNT* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_SETITEMCOUNT";
  }
  protected:
  explicit S_SETITEMCOUNT(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
    kItemCountFieldNumber = 2,
  };
  // repeated uint64 itemId = 1;
  int itemid_size() const;
  private:
  int _internal_itemid_size() const;
  public:
  void clear_itemid();
  private:
  uint64_t _internal_itemid(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_itemid() const;
  void _internal_add_itemid(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_itemid();
  public:
  uint64_t itemid(int index) const;
  void set_itemid(int index, uint64_t value);
  void add_itemid(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      itemid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_itemid();

  // repeated uint32 itemCount = 2;
  int itemcount_size() const;
  private:
  int _internal_itemcount_size() const;
  public:
  void clear_itemcount();
  private:
  uint32_t _internal_itemcount(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_itemcount() const;
  void _internal_add_itemcount(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_itemcount();
  public:
  uint32_t itemcount(int index) const;
  void set_itemcount(int index, uint32_t value);
  void add_itemcount(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      itemcount() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_itemcount();

  // @@protoc_insertion_point(class_scope:Protocol.S_SETITEMCOUNT)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > itemid_;
    mutable std::atomic<int> _itemid_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > itemcount_;
    mutable std::atomic<int> _itemcount_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_USEITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_USEITEM) */ {
 public:
  inline C_USEITEM() : C_USEITEM(nullptr) {}
  ~C_USEITEM() override;
  explicit PROTOBUF_CONSTEXPR C_USEITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_USEITEM(const C_USEITEM& from);
  C_USEITEM(C_USEITEM&& from) noexcept
    : C_USEITEM() {
    *this = ::std::move(from);
  }

  inline C_USEITEM& operator=(const C_USEITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_USEITEM& operator=(C_USEITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_USEITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_USEITEM* internal_default_instance() {
    return reinterpret_cast<const C_USEITEM*>(
               &_C_USEITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(C_USEITEM& a, C_USEITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(C_USEITEM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_USEITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_USEITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_USEITEM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_USEITEM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_USEITEM& from) {
    C_USEITEM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_USEITEM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_USEITEM";
  }
  protected:
  explicit C_USEITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
  };
  // uint64 itemId = 1;
  void clear_itemid();
  uint64_t itemid() const;
  void set_itemid(uint64_t value);
  private:
  uint64_t _internal_itemid() const;
  void _internal_set_itemid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_USEITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t itemid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_REMOVEITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_REMOVEITEM) */ {
 public:
  inline C_REMOVEITEM() : C_REMOVEITEM(nullptr) {}
  ~C_REMOVEITEM() override;
  explicit PROTOBUF_CONSTEXPR C_REMOVEITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_REMOVEITEM(const C_REMOVEITEM& from);
  C_REMOVEITEM(C_REMOVEITEM&& from) noexcept
    : C_REMOVEITEM() {
    *this = ::std::move(from);
  }

  inline C_REMOVEITEM& operator=(const C_REMOVEITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_REMOVEITEM& operator=(C_REMOVEITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_REMOVEITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_REMOVEITEM* internal_default_instance() {
    return reinterpret_cast<const C_REMOVEITEM*>(
               &_C_REMOVEITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(C_REMOVEITEM& a, C_REMOVEITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(C_REMOVEITEM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_REMOVEITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_REMOVEITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_REMOVEITEM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_REMOVEITEM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_REMOVEITEM& from) {
    C_REMOVEITEM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_REMOVEITEM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_REMOVEITEM";
  }
  protected:
  explicit C_REMOVEITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
    kRemoveCountFieldNumber = 2,
    kBSellFieldNumber = 3,
  };
  // repeated uint64 ItemId = 1;
  int itemid_size() const;
  private:
  int _internal_itemid_size() const;
  public:
  void clear_itemid();
  private:
  uint64_t _internal_itemid(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_itemid() const;
  void _internal_add_itemid(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_itemid();
  public:
  uint64_t itemid(int index) const;
  void set_itemid(int index, uint64_t value);
  void add_itemid(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      itemid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_itemid();

  // repeated int32 removeCount = 2;
  int removecount_size() const;
  private:
  int _internal_removecount_size() const;
  public:
  void clear_removecount();
  private:
  int32_t _internal_removecount(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_removecount() const;
  void _internal_add_removecount(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_removecount();
  public:
  int32_t removecount(int index) const;
  void set_removecount(int index, int32_t value);
  void add_removecount(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      removecount() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_removecount();

  // bool bSell = 3;
  void clear_bsell();
  bool bsell() const;
  void set_bsell(bool value);
  private:
  bool _internal_bsell() const;
  void _internal_set_bsell(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_REMOVEITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > itemid_;
    mutable std::atomic<int> _itemid_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > removecount_;
    mutable std::atomic<int> _removecount_cached_byte_size_;
    bool bsell_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_REMOVEITEM final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_REMOVEITEM) */ {
 public:
  inline S_REMOVEITEM() : S_REMOVEITEM(nullptr) {}
  ~S_REMOVEITEM() override;
  explicit PROTOBUF_CONSTEXPR S_REMOVEITEM(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_REMOVEITEM(const S_REMOVEITEM& from);
  S_REMOVEITEM(S_REMOVEITEM&& from) noexcept
    : S_REMOVEITEM() {
    *this = ::std::move(from);
  }

  inline S_REMOVEITEM& operator=(const S_REMOVEITEM& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_REMOVEITEM& operator=(S_REMOVEITEM&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_REMOVEITEM& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_REMOVEITEM* internal_default_instance() {
    return reinterpret_cast<const S_REMOVEITEM*>(
               &_S_REMOVEITEM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(S_REMOVEITEM& a, S_REMOVEITEM& b) {
    a.Swap(&b);
  }
  inline void Swap(S_REMOVEITEM* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_REMOVEITEM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_REMOVEITEM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_REMOVEITEM>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_REMOVEITEM& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_REMOVEITEM& from) {
    S_REMOVEITEM::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_REMOVEITEM* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_REMOVEITEM";
  }
  protected:
  explicit S_REMOVEITEM(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
  };
  // repeated uint64 itemId = 1;
  int itemid_size() const;
  private:
  int _internal_itemid_size() const;
  public:
  void clear_itemid();
  private:
  uint64_t _internal_itemid(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_itemid() const;
  void _internal_add_itemid(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_itemid();
  public:
  uint64_t itemid(int index) const;
  void set_itemid(int index, uint64_t value);
  void add_itemid(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      itemid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_itemid();

  // @@protoc_insertion_point(class_scope:Protocol.S_REMOVEITEM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > itemid_;
    mutable std::atomic<int> _itemid_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_STATCHANGED final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_STATCHANGED) */ {
 public:
  inline S_STATCHANGED() : S_STATCHANGED(nullptr) {}
  ~S_STATCHANGED() override;
  explicit PROTOBUF_CONSTEXPR S_STATCHANGED(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_STATCHANGED(const S_STATCHANGED& from);
  S_STATCHANGED(S_STATCHANGED&& from) noexcept
    : S_STATCHANGED() {
    *this = ::std::move(from);
  }

  inline S_STATCHANGED& operator=(const S_STATCHANGED& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_STATCHANGED& operator=(S_STATCHANGED&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_STATCHANGED& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_STATCHANGED* internal_default_instance() {
    return reinterpret_cast<const S_STATCHANGED*>(
               &_S_STATCHANGED_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(S_STATCHANGED& a, S_STATCHANGED& b) {
    a.Swap(&b);
  }
  inline void Swap(S_STATCHANGED* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_STATCHANGED* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_STATCHANGED* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_STATCHANGED>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_STATCHANGED& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_STATCHANGED& from) {
    S_STATCHANGED::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_STATCHANGED* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_STATCHANGED";
  }
  protected:
  explicit S_STATCHANGED(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatInfoFieldNumber = 2,
    kObjectIdFieldNumber = 1,
  };
  // .Protocol.StatInfo statInfo = 2;
  bool has_statinfo() const;
  private:
  bool _internal_has_statinfo() const;
  public:
  void clear_statinfo();
  const ::Protocol::StatInfo& statinfo() const;
  PROTOBUF_NODISCARD ::Protocol::StatInfo* release_statinfo();
  ::Protocol::StatInfo* mutable_statinfo();
  void set_allocated_statinfo(::Protocol::StatInfo* statinfo);
  private:
  const ::Protocol::StatInfo& _internal_statinfo() const;
  ::Protocol::StatInfo* _internal_mutable_statinfo();
  public:
  void unsafe_arena_set_allocated_statinfo(
      ::Protocol::StatInfo* statinfo);
  ::Protocol::StatInfo* unsafe_arena_release_statinfo();

  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_STATCHANGED)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::StatInfo* statinfo_;
    uint64_t object_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_LEVEL_UP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_LEVEL_UP) */ {
 public:
  inline S_LEVEL_UP() : S_LEVEL_UP(nullptr) {}
  ~S_LEVEL_UP() override;
  explicit PROTOBUF_CONSTEXPR S_LEVEL_UP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LEVEL_UP(const S_LEVEL_UP& from);
  S_LEVEL_UP(S_LEVEL_UP&& from) noexcept
    : S_LEVEL_UP() {
    *this = ::std::move(from);
  }

  inline S_LEVEL_UP& operator=(const S_LEVEL_UP& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LEVEL_UP& operator=(S_LEVEL_UP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LEVEL_UP& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LEVEL_UP* internal_default_instance() {
    return reinterpret_cast<const S_LEVEL_UP*>(
               &_S_LEVEL_UP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(S_LEVEL_UP& a, S_LEVEL_UP& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LEVEL_UP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LEVEL_UP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_LEVEL_UP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_LEVEL_UP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_LEVEL_UP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_LEVEL_UP& from) {
    S_LEVEL_UP::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_LEVEL_UP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_LEVEL_UP";
  }
  protected:
  explicit S_LEVEL_UP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kLevelFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // int32 level = 2;
  void clear_level();
  int32_t level() const;
  void set_level(int32_t value);
  private:
  int32_t _internal_level() const;
  void _internal_set_level(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_LEVEL_UP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    int32_t level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_UPGRADESKILL final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_UPGRADESKILL) */ {
 public:
  inline C_UPGRADESKILL() : C_UPGRADESKILL(nullptr) {}
  ~C_UPGRADESKILL() override;
  explicit PROTOBUF_CONSTEXPR C_UPGRADESKILL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_UPGRADESKILL(const C_UPGRADESKILL& from);
  C_UPGRADESKILL(C_UPGRADESKILL&& from) noexcept
    : C_UPGRADESKILL() {
    *this = ::std::move(from);
  }

  inline C_UPGRADESKILL& operator=(const C_UPGRADESKILL& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_UPGRADESKILL& operator=(C_UPGRADESKILL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_UPGRADESKILL& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_UPGRADESKILL* internal_default_instance() {
    return reinterpret_cast<const C_UPGRADESKILL*>(
               &_C_UPGRADESKILL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(C_UPGRADESKILL& a, C_UPGRADESKILL& b) {
    a.Swap(&b);
  }
  inline void Swap(C_UPGRADESKILL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_UPGRADESKILL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_UPGRADESKILL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_UPGRADESKILL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_UPGRADESKILL& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_UPGRADESKILL& from) {
    C_UPGRADESKILL::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_UPGRADESKILL* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_UPGRADESKILL";
  }
  protected:
  explicit C_UPGRADESKILL(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kSkillIdFieldNumber = 2,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // int32 skillId = 2;
  void clear_skillid();
  int32_t skillid() const;
  void set_skillid(int32_t value);
  private:
  int32_t _internal_skillid() const;
  void _internal_set_skillid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_UPGRADESKILL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    int32_t skillid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_UPGRADESKILL final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_UPGRADESKILL) */ {
 public:
  inline S_UPGRADESKILL() : S_UPGRADESKILL(nullptr) {}
  ~S_UPGRADESKILL() override;
  explicit PROTOBUF_CONSTEXPR S_UPGRADESKILL(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_UPGRADESKILL(const S_UPGRADESKILL& from);
  S_UPGRADESKILL(S_UPGRADESKILL&& from) noexcept
    : S_UPGRADESKILL() {
    *this = ::std::move(from);
  }

  inline S_UPGRADESKILL& operator=(const S_UPGRADESKILL& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_UPGRADESKILL& operator=(S_UPGRADESKILL&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_UPGRADESKILL& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_UPGRADESKILL* internal_default_instance() {
    return reinterpret_cast<const S_UPGRADESKILL*>(
               &_S_UPGRADESKILL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(S_UPGRADESKILL& a, S_UPGRADESKILL& b) {
    a.Swap(&b);
  }
  inline void Swap(S_UPGRADESKILL* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_UPGRADESKILL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_UPGRADESKILL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_UPGRADESKILL>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_UPGRADESKILL& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_UPGRADESKILL& from) {
    S_UPGRADESKILL::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_UPGRADESKILL* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_UPGRADESKILL";
  }
  protected:
  explicit S_UPGRADESKILL(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kSkillIdFieldNumber = 2,
    kSkillLevelFieldNumber = 3,
    kLeftPointFieldNumber = 4,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // int32 skillId = 2;
  void clear_skillid();
  int32_t skillid() const;
  void set_skillid(int32_t value);
  private:
  int32_t _internal_skillid() const;
  void _internal_set_skillid(int32_t value);
  public:

  // int32 skillLevel = 3;
  void clear_skilllevel();
  int32_t skilllevel() const;
  void set_skilllevel(int32_t value);
  private:
  int32_t _internal_skilllevel() const;
  void _internal_set_skilllevel(int32_t value);
  public:

  // int32 leftPoint = 4;
  void clear_leftpoint();
  int32_t leftpoint() const;
  void set_leftpoint(int32_t value);
  private:
  int32_t _internal_leftpoint() const;
  void _internal_set_leftpoint(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_UPGRADESKILL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    int32_t skillid_;
    int32_t skilllevel_;
    int32_t leftpoint_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_QUEST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_QUEST) */ {
 public:
  inline C_QUEST() : C_QUEST(nullptr) {}
  ~C_QUEST() override;
  explicit PROTOBUF_CONSTEXPR C_QUEST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_QUEST(const C_QUEST& from);
  C_QUEST(C_QUEST&& from) noexcept
    : C_QUEST() {
    *this = ::std::move(from);
  }

  inline C_QUEST& operator=(const C_QUEST& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_QUEST& operator=(C_QUEST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_QUEST& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_QUEST* internal_default_instance() {
    return reinterpret_cast<const C_QUEST*>(
               &_C_QUEST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(C_QUEST& a, C_QUEST& b) {
    a.Swap(&b);
  }
  inline void Swap(C_QUEST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_QUEST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_QUEST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_QUEST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_QUEST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_QUEST& from) {
    C_QUEST::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_QUEST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_QUEST";
  }
  protected:
  explicit C_QUEST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuestIdFieldNumber = 1,
    kQuestStateFieldNumber = 2,
  };
  // repeated int32 questId = 1;
  int questid_size() const;
  private:
  int _internal_questid_size() const;
  public:
  void clear_questid();
  private:
  int32_t _internal_questid(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_questid() const;
  void _internal_add_questid(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_questid();
  public:
  int32_t questid(int index) const;
  void set_questid(int index, int32_t value);
  void add_questid(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      questid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_questid();

  // repeated .Protocol.EQuestState questState = 2;
  int queststate_size() const;
  private:
  int _internal_queststate_size() const;
  public:
  void clear_queststate();
  private:
  ::Protocol::EQuestState _internal_queststate(int index) const;
  void _internal_add_queststate(::Protocol::EQuestState value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_queststate();
  public:
  ::Protocol::EQuestState queststate(int index) const;
  void set_queststate(int index, ::Protocol::EQuestState value);
  void add_queststate(::Protocol::EQuestState value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& queststate() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_queststate();

  // @@protoc_insertion_point(class_scope:Protocol.C_QUEST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > questid_;
    mutable std::atomic<int> _questid_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> queststate_;
    mutable std::atomic<int> _queststate_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_QUEST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_QUEST) */ {
 public:
  inline S_QUEST() : S_QUEST(nullptr) {}
  ~S_QUEST() override;
  explicit PROTOBUF_CONSTEXPR S_QUEST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_QUEST(const S_QUEST& from);
  S_QUEST(S_QUEST&& from) noexcept
    : S_QUEST() {
    *this = ::std::move(from);
  }

  inline S_QUEST& operator=(const S_QUEST& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_QUEST& operator=(S_QUEST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_QUEST& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_QUEST* internal_default_instance() {
    return reinterpret_cast<const S_QUEST*>(
               &_S_QUEST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(S_QUEST& a, S_QUEST& b) {
    a.Swap(&b);
  }
  inline void Swap(S_QUEST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_QUEST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_QUEST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_QUEST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_QUEST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_QUEST& from) {
    S_QUEST::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_QUEST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_QUEST";
  }
  protected:
  explicit S_QUEST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuestIdFieldNumber = 1,
    kQuestStateFieldNumber = 2,
  };
  // repeated int32 questId = 1;
  int questid_size() const;
  private:
  int _internal_questid_size() const;
  public:
  void clear_questid();
  private:
  int32_t _internal_questid(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_questid() const;
  void _internal_add_questid(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_questid();
  public:
  int32_t questid(int index) const;
  void set_questid(int index, int32_t value);
  void add_questid(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      questid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_questid();

  // repeated .Protocol.EQuestState questState = 2;
  int queststate_size() const;
  private:
  int _internal_queststate_size() const;
  public:
  void clear_queststate();
  private:
  ::Protocol::EQuestState _internal_queststate(int index) const;
  void _internal_add_queststate(::Protocol::EQuestState value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_queststate();
  public:
  ::Protocol::EQuestState queststate(int index) const;
  void set_queststate(int index, ::Protocol::EQuestState value);
  void add_queststate(::Protocol::EQuestState value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& queststate() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_queststate();

  // @@protoc_insertion_point(class_scope:Protocol.S_QUEST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > questid_;
    mutable std::atomic<int> _questid_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> queststate_;
    mutable std::atomic<int> _queststate_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_RENEW_TARGET final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_RENEW_TARGET) */ {
 public:
  inline C_RENEW_TARGET() : C_RENEW_TARGET(nullptr) {}
  ~C_RENEW_TARGET() override;
  explicit PROTOBUF_CONSTEXPR C_RENEW_TARGET(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_RENEW_TARGET(const C_RENEW_TARGET& from);
  C_RENEW_TARGET(C_RENEW_TARGET&& from) noexcept
    : C_RENEW_TARGET() {
    *this = ::std::move(from);
  }

  inline C_RENEW_TARGET& operator=(const C_RENEW_TARGET& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_RENEW_TARGET& operator=(C_RENEW_TARGET&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_RENEW_TARGET& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_RENEW_TARGET* internal_default_instance() {
    return reinterpret_cast<const C_RENEW_TARGET*>(
               &_C_RENEW_TARGET_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(C_RENEW_TARGET& a, C_RENEW_TARGET& b) {
    a.Swap(&b);
  }
  inline void Swap(C_RENEW_TARGET* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_RENEW_TARGET* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_RENEW_TARGET* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_RENEW_TARGET>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_RENEW_TARGET& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_RENEW_TARGET& from) {
    C_RENEW_TARGET::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_RENEW_TARGET* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_RENEW_TARGET";
  }
  protected:
  explicit C_RENEW_TARGET(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetIdFieldNumber = 1,
    kTargetCountFieldNumber = 2,
    kTargetTypeFieldNumber = 3,
    kQuestIdFieldNumber = 4,
  };
  // int32 targetId = 1;
  void clear_targetid();
  int32_t targetid() const;
  void set_targetid(int32_t value);
  private:
  int32_t _internal_targetid() const;
  void _internal_set_targetid(int32_t value);
  public:

  // int32 targetCount = 2;
  void clear_targetcount();
  int32_t targetcount() const;
  void set_targetcount(int32_t value);
  private:
  int32_t _internal_targetcount() const;
  void _internal_set_targetcount(int32_t value);
  public:

  // .Protocol.ETargetType targetType = 3;
  void clear_targettype();
  ::Protocol::ETargetType targettype() const;
  void set_targettype(::Protocol::ETargetType value);
  private:
  ::Protocol::ETargetType _internal_targettype() const;
  void _internal_set_targettype(::Protocol::ETargetType value);
  public:

  // int32 questId = 4;
  void clear_questid();
  int32_t questid() const;
  void set_questid(int32_t value);
  private:
  int32_t _internal_questid() const;
  void _internal_set_questid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_RENEW_TARGET)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t targetid_;
    int32_t targetcount_;
    int targettype_;
    int32_t questid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_LOAD_TARGET final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_LOAD_TARGET) */ {
 public:
  inline S_LOAD_TARGET() : S_LOAD_TARGET(nullptr) {}
  ~S_LOAD_TARGET() override;
  explicit PROTOBUF_CONSTEXPR S_LOAD_TARGET(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_LOAD_TARGET(const S_LOAD_TARGET& from);
  S_LOAD_TARGET(S_LOAD_TARGET&& from) noexcept
    : S_LOAD_TARGET() {
    *this = ::std::move(from);
  }

  inline S_LOAD_TARGET& operator=(const S_LOAD_TARGET& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_LOAD_TARGET& operator=(S_LOAD_TARGET&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_LOAD_TARGET& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_LOAD_TARGET* internal_default_instance() {
    return reinterpret_cast<const S_LOAD_TARGET*>(
               &_S_LOAD_TARGET_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(S_LOAD_TARGET& a, S_LOAD_TARGET& b) {
    a.Swap(&b);
  }
  inline void Swap(S_LOAD_TARGET* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_LOAD_TARGET* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_LOAD_TARGET* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_LOAD_TARGET>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_LOAD_TARGET& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_LOAD_TARGET& from) {
    S_LOAD_TARGET::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_LOAD_TARGET* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_LOAD_TARGET";
  }
  protected:
  explicit S_LOAD_TARGET(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuestIdFieldNumber = 1,
    kTargetIndexFieldNumber = 2,
    kTargetCountFieldNumber = 3,
  };
  // repeated int32 questId = 1;
  int questid_size() const;
  private:
  int _internal_questid_size() const;
  public:
  void clear_questid();
  private:
  int32_t _internal_questid(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_questid() const;
  void _internal_add_questid(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_questid();
  public:
  int32_t questid(int index) const;
  void set_questid(int index, int32_t value);
  void add_questid(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      questid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_questid();

  // repeated int32 targetIndex = 2;
  int targetindex_size() const;
  private:
  int _internal_targetindex_size() const;
  public:
  void clear_targetindex();
  private:
  int32_t _internal_targetindex(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_targetindex() const;
  void _internal_add_targetindex(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_targetindex();
  public:
  int32_t targetindex(int index) const;
  void set_targetindex(int index, int32_t value);
  void add_targetindex(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      targetindex() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_targetindex();

  // repeated int32 targetCount = 3;
  int targetcount_size() const;
  private:
  int _internal_targetcount_size() const;
  public:
  void clear_targetcount();
  private:
  int32_t _internal_targetcount(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_targetcount() const;
  void _internal_add_targetcount(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_targetcount();
  public:
  int32_t targetcount(int index) const;
  void set_targetcount(int index, int32_t value);
  void add_targetcount(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      targetcount() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_targetcount();

  // @@protoc_insertion_point(class_scope:Protocol.S_LOAD_TARGET)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > questid_;
    mutable std::atomic<int> _questid_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > targetindex_;
    mutable std::atomic<int> _targetindex_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > targetcount_;
    mutable std::atomic<int> _targetcount_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C_QUICK_QUEST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C_QUICK_QUEST) */ {
 public:
  inline C_QUICK_QUEST() : C_QUICK_QUEST(nullptr) {}
  ~C_QUICK_QUEST() override;
  explicit PROTOBUF_CONSTEXPR C_QUICK_QUEST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C_QUICK_QUEST(const C_QUICK_QUEST& from);
  C_QUICK_QUEST(C_QUICK_QUEST&& from) noexcept
    : C_QUICK_QUEST() {
    *this = ::std::move(from);
  }

  inline C_QUICK_QUEST& operator=(const C_QUICK_QUEST& from) {
    CopyFrom(from);
    return *this;
  }
  inline C_QUICK_QUEST& operator=(C_QUICK_QUEST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C_QUICK_QUEST& default_instance() {
    return *internal_default_instance();
  }
  static inline const C_QUICK_QUEST* internal_default_instance() {
    return reinterpret_cast<const C_QUICK_QUEST*>(
               &_C_QUICK_QUEST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(C_QUICK_QUEST& a, C_QUICK_QUEST& b) {
    a.Swap(&b);
  }
  inline void Swap(C_QUICK_QUEST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C_QUICK_QUEST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C_QUICK_QUEST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C_QUICK_QUEST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C_QUICK_QUEST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C_QUICK_QUEST& from) {
    C_QUICK_QUEST::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C_QUICK_QUEST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C_QUICK_QUEST";
  }
  protected:
  explicit C_QUICK_QUEST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kQuestIdFieldNumber = 2,
    kIsRemoveFieldNumber = 3,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // int32 questId = 2;
  void clear_questid();
  int32_t questid() const;
  void set_questid(int32_t value);
  private:
  int32_t _internal_questid() const;
  void _internal_set_questid(int32_t value);
  public:

  // bool isRemove = 3;
  void clear_isremove();
  bool isremove() const;
  void set_isremove(bool value);
  private:
  bool _internal_isremove() const;
  void _internal_set_isremove(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C_QUICK_QUEST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    int32_t questid_;
    bool isremove_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_QUICK_QUEST final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_QUICK_QUEST) */ {
 public:
  inline S_QUICK_QUEST() : S_QUICK_QUEST(nullptr) {}
  ~S_QUICK_QUEST() override;
  explicit PROTOBUF_CONSTEXPR S_QUICK_QUEST(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_QUICK_QUEST(const S_QUICK_QUEST& from);
  S_QUICK_QUEST(S_QUICK_QUEST&& from) noexcept
    : S_QUICK_QUEST() {
    *this = ::std::move(from);
  }

  inline S_QUICK_QUEST& operator=(const S_QUICK_QUEST& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_QUICK_QUEST& operator=(S_QUICK_QUEST&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_QUICK_QUEST& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_QUICK_QUEST* internal_default_instance() {
    return reinterpret_cast<const S_QUICK_QUEST*>(
               &_S_QUICK_QUEST_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(S_QUICK_QUEST& a, S_QUICK_QUEST& b) {
    a.Swap(&b);
  }
  inline void Swap(S_QUICK_QUEST* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_QUICK_QUEST* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_QUICK_QUEST* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_QUICK_QUEST>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_QUICK_QUEST& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_QUICK_QUEST& from) {
    S_QUICK_QUEST::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_QUICK_QUEST* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_QUICK_QUEST";
  }
  protected:
  explicit S_QUICK_QUEST(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuestIdFieldNumber = 1,
  };
  // repeated int32 questId = 1;
  int questid_size() const;
  private:
  int _internal_questid_size() const;
  public:
  void clear_questid();
  private:
  int32_t _internal_questid(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_questid() const;
  void _internal_add_questid(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_questid();
  public:
  int32_t questid(int index) const;
  void set_questid(int index, int32_t value);
  void add_questid(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      questid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_questid();

  // @@protoc_insertion_point(class_scope:Protocol.S_QUICK_QUEST)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > questid_;
    mutable std::atomic<int> _questid_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S_SET_DATA final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S_SET_DATA) */ {
 public:
  inline S_SET_DATA() : S_SET_DATA(nullptr) {}
  ~S_SET_DATA() override;
  explicit PROTOBUF_CONSTEXPR S_SET_DATA(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_SET_DATA(const S_SET_DATA& from);
  S_SET_DATA(S_SET_DATA&& from) noexcept
    : S_SET_DATA() {
    *this = ::std::move(from);
  }

  inline S_SET_DATA& operator=(const S_SET_DATA& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_SET_DATA& operator=(S_SET_DATA&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_SET_DATA& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_SET_DATA* internal_default_instance() {
    return reinterpret_cast<const S_SET_DATA*>(
               &_S_SET_DATA_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(S_SET_DATA& a, S_SET_DATA& b) {
    a.Swap(&b);
  }
  inline void Swap(S_SET_DATA* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_SET_DATA* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_SET_DATA* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_SET_DATA>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_SET_DATA& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S_SET_DATA& from) {
    S_SET_DATA::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_SET_DATA* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S_SET_DATA";
  }
  protected:
  explicit S_SET_DATA(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 1,
    kDataTypeFieldNumber = 2,
    kObjectTypeFieldNumber = 3,
  };
  // uint64 object_id = 1;
  void clear_object_id();
  uint64_t object_id() const;
  void set_object_id(uint64_t value);
  private:
  uint64_t _internal_object_id() const;
  void _internal_set_object_id(uint64_t value);
  public:

  // .Protocol.EPlayerData dataType = 2;
  void clear_datatype();
  ::Protocol::EPlayerData datatype() const;
  void set_datatype(::Protocol::EPlayerData value);
  private:
  ::Protocol::EPlayerData _internal_datatype() const;
  void _internal_set_datatype(::Protocol::EPlayerData value);
  public:

  // .Protocol.ECharacterType objectType = 3;
  void clear_objecttype();
  ::Protocol::ECharacterType objecttype() const;
  void set_objecttype(::Protocol::ECharacterType value);
  private:
  ::Protocol::ECharacterType _internal_objecttype() const;
  void _internal_set_objecttype(::Protocol::ECharacterType value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S_SET_DATA)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t object_id_;
    int datatype_;
    int objecttype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// C_LOGIN

// string id = 1;
inline void C_LOGIN::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& C_LOGIN::id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_LOGIN.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_LOGIN::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_LOGIN.id)
}
inline std::string* C_LOGIN::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:Protocol.C_LOGIN.id)
  return _s;
}
inline const std::string& C_LOGIN::_internal_id() const {
  return _impl_.id_.Get();
}
inline void C_LOGIN::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* C_LOGIN::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* C_LOGIN::release_id() {
  // @@protoc_insertion_point(field_release:Protocol.C_LOGIN.id)
  return _impl_.id_.Release();
}
inline void C_LOGIN::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_LOGIN.id)
}

// -------------------------------------------------------------------

// S_LOGIN

// uint64 userdbid = 1;
inline void S_LOGIN::clear_userdbid() {
  _impl_.userdbid_ = uint64_t{0u};
}
inline uint64_t S_LOGIN::_internal_userdbid() const {
  return _impl_.userdbid_;
}
inline uint64_t S_LOGIN::userdbid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_LOGIN.userdbid)
  return _internal_userdbid();
}
inline void S_LOGIN::_internal_set_userdbid(uint64_t value) {
  
  _impl_.userdbid_ = value;
}
inline void S_LOGIN::set_userdbid(uint64_t value) {
  _internal_set_userdbid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_LOGIN.userdbid)
}

// repeated .Protocol.BaseCharacterInfo characters = 2;
inline int S_LOGIN::_internal_characters_size() const {
  return _impl_.characters_.size();
}
inline int S_LOGIN::characters_size() const {
  return _internal_characters_size();
}
inline ::Protocol::BaseCharacterInfo* S_LOGIN::mutable_characters(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_LOGIN.characters)
  return _impl_.characters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::BaseCharacterInfo >*
S_LOGIN::mutable_characters() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_LOGIN.characters)
  return &_impl_.characters_;
}
inline const ::Protocol::BaseCharacterInfo& S_LOGIN::_internal_characters(int index) const {
  return _impl_.characters_.Get(index);
}
inline const ::Protocol::BaseCharacterInfo& S_LOGIN::characters(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_LOGIN.characters)
  return _internal_characters(index);
}
inline ::Protocol::BaseCharacterInfo* S_LOGIN::_internal_add_characters() {
  return _impl_.characters_.Add();
}
inline ::Protocol::BaseCharacterInfo* S_LOGIN::add_characters() {
  ::Protocol::BaseCharacterInfo* _add = _internal_add_characters();
  // @@protoc_insertion_point(field_add:Protocol.S_LOGIN.characters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::BaseCharacterInfo >&
S_LOGIN::characters() const {
  // @@protoc_insertion_point(field_list:Protocol.S_LOGIN.characters)
  return _impl_.characters_;
}

// -------------------------------------------------------------------

// C_CHECKNAME

// string name = 1;
inline void C_CHECKNAME::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& C_CHECKNAME::name() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CHECKNAME.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_CHECKNAME::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_CHECKNAME.name)
}
inline std::string* C_CHECKNAME::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Protocol.C_CHECKNAME.name)
  return _s;
}
inline const std::string& C_CHECKNAME::_internal_name() const {
  return _impl_.name_.Get();
}
inline void C_CHECKNAME::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* C_CHECKNAME::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* C_CHECKNAME::release_name() {
  // @@protoc_insertion_point(field_release:Protocol.C_CHECKNAME.name)
  return _impl_.name_.Release();
}
inline void C_CHECKNAME::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_CHECKNAME.name)
}

// -------------------------------------------------------------------

// S_CHECKNAME

// string name = 1;
inline void S_CHECKNAME::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& S_CHECKNAME::name() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CHECKNAME.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_CHECKNAME::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_CHECKNAME.name)
}
inline std::string* S_CHECKNAME::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Protocol.S_CHECKNAME.name)
  return _s;
}
inline const std::string& S_CHECKNAME::_internal_name() const {
  return _impl_.name_.Get();
}
inline void S_CHECKNAME::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* S_CHECKNAME::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* S_CHECKNAME::release_name() {
  // @@protoc_insertion_point(field_release:Protocol.S_CHECKNAME.name)
  return _impl_.name_.Release();
}
inline void S_CHECKNAME::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_CHECKNAME.name)
}

// bool duplication = 2;
inline void S_CHECKNAME::clear_duplication() {
  _impl_.duplication_ = false;
}
inline bool S_CHECKNAME::_internal_duplication() const {
  return _impl_.duplication_;
}
inline bool S_CHECKNAME::duplication() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CHECKNAME.duplication)
  return _internal_duplication();
}
inline void S_CHECKNAME::_internal_set_duplication(bool value) {
  
  _impl_.duplication_ = value;
}
inline void S_CHECKNAME::set_duplication(bool value) {
  _internal_set_duplication(value);
  // @@protoc_insertion_point(field_set:Protocol.S_CHECKNAME.duplication)
}

// -------------------------------------------------------------------

// C_ENTER_GAME

// uint64 playerId = 1;
inline void C_ENTER_GAME::clear_playerid() {
  _impl_.playerid_ = uint64_t{0u};
}
inline uint64_t C_ENTER_GAME::_internal_playerid() const {
  return _impl_.playerid_;
}
inline uint64_t C_ENTER_GAME::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ENTER_GAME.playerId)
  return _internal_playerid();
}
inline void C_ENTER_GAME::_internal_set_playerid(uint64_t value) {
  
  _impl_.playerid_ = value;
}
inline void C_ENTER_GAME::set_playerid(uint64_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ENTER_GAME.playerId)
}

// -------------------------------------------------------------------

// C_LOAD_INFO

// uint64 object_id = 1;
inline void C_LOAD_INFO::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_LOAD_INFO::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_LOAD_INFO::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_LOAD_INFO.object_id)
  return _internal_object_id();
}
inline void C_LOAD_INFO::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_LOAD_INFO::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_LOAD_INFO.object_id)
}

// -------------------------------------------------------------------

// C_CREATECHARACTER

// uint64 userId = 1;
inline void C_CREATECHARACTER::clear_userid() {
  _impl_.userid_ = uint64_t{0u};
}
inline uint64_t C_CREATECHARACTER::_internal_userid() const {
  return _impl_.userid_;
}
inline uint64_t C_CREATECHARACTER::userid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CREATECHARACTER.userId)
  return _internal_userid();
}
inline void C_CREATECHARACTER::_internal_set_userid(uint64_t value) {
  
  _impl_.userid_ = value;
}
inline void C_CREATECHARACTER::set_userid(uint64_t value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_CREATECHARACTER.userId)
}

// string name = 2;
inline void C_CREATECHARACTER::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& C_CREATECHARACTER::name() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CREATECHARACTER.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_CREATECHARACTER::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_CREATECHARACTER.name)
}
inline std::string* C_CREATECHARACTER::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Protocol.C_CREATECHARACTER.name)
  return _s;
}
inline const std::string& C_CREATECHARACTER::_internal_name() const {
  return _impl_.name_.Get();
}
inline void C_CREATECHARACTER::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* C_CREATECHARACTER::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* C_CREATECHARACTER::release_name() {
  // @@protoc_insertion_point(field_release:Protocol.C_CREATECHARACTER.name)
  return _impl_.name_.Release();
}
inline void C_CREATECHARACTER::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_CREATECHARACTER.name)
}

// .Protocol.ECharacterType type = 3;
inline void C_CREATECHARACTER::clear_type() {
  _impl_.type_ = 0;
}
inline ::Protocol::ECharacterType C_CREATECHARACTER::_internal_type() const {
  return static_cast< ::Protocol::ECharacterType >(_impl_.type_);
}
inline ::Protocol::ECharacterType C_CREATECHARACTER::type() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CREATECHARACTER.type)
  return _internal_type();
}
inline void C_CREATECHARACTER::_internal_set_type(::Protocol::ECharacterType value) {
  
  _impl_.type_ = value;
}
inline void C_CREATECHARACTER::set_type(::Protocol::ECharacterType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Protocol.C_CREATECHARACTER.type)
}

// -------------------------------------------------------------------

// S_ENTER_GAME

// bool success = 1;
inline void S_ENTER_GAME::clear_success() {
  _impl_.success_ = false;
}
inline bool S_ENTER_GAME::_internal_success() const {
  return _impl_.success_;
}
inline bool S_ENTER_GAME::success() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ENTER_GAME.success)
  return _internal_success();
}
inline void S_ENTER_GAME::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void S_ENTER_GAME::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ENTER_GAME.success)
}

// .Protocol.ObjectInfo player = 2;
inline bool S_ENTER_GAME::_internal_has_player() const {
  return this != internal_default_instance() && _impl_.player_ != nullptr;
}
inline bool S_ENTER_GAME::has_player() const {
  return _internal_has_player();
}
inline const ::Protocol::ObjectInfo& S_ENTER_GAME::_internal_player() const {
  const ::Protocol::ObjectInfo* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& S_ENTER_GAME::player() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ENTER_GAME.player)
  return _internal_player();
}
inline void S_ENTER_GAME::unsafe_arena_set_allocated_player(
    ::Protocol::ObjectInfo* player) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = player;
  if (player) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_ENTER_GAME.player)
}
inline ::Protocol::ObjectInfo* S_ENTER_GAME::release_player() {
  
  ::Protocol::ObjectInfo* temp = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ObjectInfo* S_ENTER_GAME::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_release:Protocol.S_ENTER_GAME.player)
  
  ::Protocol::ObjectInfo* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* S_ENTER_GAME::_internal_mutable_player() {
  
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    _impl_.player_ = p;
  }
  return _impl_.player_;
}
inline ::Protocol::ObjectInfo* S_ENTER_GAME::mutable_player() {
  ::Protocol::ObjectInfo* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:Protocol.S_ENTER_GAME.player)
  return _msg;
}
inline void S_ENTER_GAME::set_allocated_player(::Protocol::ObjectInfo* player) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.player_);
  }
  if (player) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player));
    if (message_arena != submessage_arena) {
      player = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.player_ = player;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_ENTER_GAME.player)
}

// .Protocol.StatInfo stat = 3;
inline bool S_ENTER_GAME::_internal_has_stat() const {
  return this != internal_default_instance() && _impl_.stat_ != nullptr;
}
inline bool S_ENTER_GAME::has_stat() const {
  return _internal_has_stat();
}
inline const ::Protocol::StatInfo& S_ENTER_GAME::_internal_stat() const {
  const ::Protocol::StatInfo* p = _impl_.stat_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::StatInfo&>(
      ::Protocol::_StatInfo_default_instance_);
}
inline const ::Protocol::StatInfo& S_ENTER_GAME::stat() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ENTER_GAME.stat)
  return _internal_stat();
}
inline void S_ENTER_GAME::unsafe_arena_set_allocated_stat(
    ::Protocol::StatInfo* stat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stat_);
  }
  _impl_.stat_ = stat;
  if (stat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_ENTER_GAME.stat)
}
inline ::Protocol::StatInfo* S_ENTER_GAME::release_stat() {
  
  ::Protocol::StatInfo* temp = _impl_.stat_;
  _impl_.stat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::StatInfo* S_ENTER_GAME::unsafe_arena_release_stat() {
  // @@protoc_insertion_point(field_release:Protocol.S_ENTER_GAME.stat)
  
  ::Protocol::StatInfo* temp = _impl_.stat_;
  _impl_.stat_ = nullptr;
  return temp;
}
inline ::Protocol::StatInfo* S_ENTER_GAME::_internal_mutable_stat() {
  
  if (_impl_.stat_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::StatInfo>(GetArenaForAllocation());
    _impl_.stat_ = p;
  }
  return _impl_.stat_;
}
inline ::Protocol::StatInfo* S_ENTER_GAME::mutable_stat() {
  ::Protocol::StatInfo* _msg = _internal_mutable_stat();
  // @@protoc_insertion_point(field_mutable:Protocol.S_ENTER_GAME.stat)
  return _msg;
}
inline void S_ENTER_GAME::set_allocated_stat(::Protocol::StatInfo* stat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stat_);
  }
  if (stat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stat));
    if (message_arena != submessage_arena) {
      stat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stat, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.stat_ = stat;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_ENTER_GAME.stat)
}

// int32 skillPoint = 4;
inline void S_ENTER_GAME::clear_skillpoint() {
  _impl_.skillpoint_ = 0;
}
inline int32_t S_ENTER_GAME::_internal_skillpoint() const {
  return _impl_.skillpoint_;
}
inline int32_t S_ENTER_GAME::skillpoint() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ENTER_GAME.skillPoint)
  return _internal_skillpoint();
}
inline void S_ENTER_GAME::_internal_set_skillpoint(int32_t value) {
  
  _impl_.skillpoint_ = value;
}
inline void S_ENTER_GAME::set_skillpoint(int32_t value) {
  _internal_set_skillpoint(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ENTER_GAME.skillPoint)
}

// string playerName = 5;
inline void S_ENTER_GAME::clear_playername() {
  _impl_.playername_.ClearToEmpty();
}
inline const std::string& S_ENTER_GAME::playername() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ENTER_GAME.playerName)
  return _internal_playername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_ENTER_GAME::set_playername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.playername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_ENTER_GAME.playerName)
}
inline std::string* S_ENTER_GAME::mutable_playername() {
  std::string* _s = _internal_mutable_playername();
  // @@protoc_insertion_point(field_mutable:Protocol.S_ENTER_GAME.playerName)
  return _s;
}
inline const std::string& S_ENTER_GAME::_internal_playername() const {
  return _impl_.playername_.Get();
}
inline void S_ENTER_GAME::_internal_set_playername(const std::string& value) {
  
  _impl_.playername_.Set(value, GetArenaForAllocation());
}
inline std::string* S_ENTER_GAME::_internal_mutable_playername() {
  
  return _impl_.playername_.Mutable(GetArenaForAllocation());
}
inline std::string* S_ENTER_GAME::release_playername() {
  // @@protoc_insertion_point(field_release:Protocol.S_ENTER_GAME.playerName)
  return _impl_.playername_.Release();
}
inline void S_ENTER_GAME::set_allocated_playername(std::string* playername) {
  if (playername != nullptr) {
    
  } else {
    
  }
  _impl_.playername_.SetAllocated(playername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.playername_.IsDefault()) {
    _impl_.playername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_ENTER_GAME.playerName)
}

// -------------------------------------------------------------------

// S_LOAD_SKILL

// repeated int32 skillIds = 1;
inline int S_LOAD_SKILL::_internal_skillids_size() const {
  return _impl_.skillids_.size();
}
inline int S_LOAD_SKILL::skillids_size() const {
  return _internal_skillids_size();
}
inline void S_LOAD_SKILL::clear_skillids() {
  _impl_.skillids_.Clear();
}
inline int32_t S_LOAD_SKILL::_internal_skillids(int index) const {
  return _impl_.skillids_.Get(index);
}
inline int32_t S_LOAD_SKILL::skillids(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_LOAD_SKILL.skillIds)
  return _internal_skillids(index);
}
inline void S_LOAD_SKILL::set_skillids(int index, int32_t value) {
  _impl_.skillids_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.S_LOAD_SKILL.skillIds)
}
inline void S_LOAD_SKILL::_internal_add_skillids(int32_t value) {
  _impl_.skillids_.Add(value);
}
inline void S_LOAD_SKILL::add_skillids(int32_t value) {
  _internal_add_skillids(value);
  // @@protoc_insertion_point(field_add:Protocol.S_LOAD_SKILL.skillIds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
S_LOAD_SKILL::_internal_skillids() const {
  return _impl_.skillids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
S_LOAD_SKILL::skillids() const {
  // @@protoc_insertion_point(field_list:Protocol.S_LOAD_SKILL.skillIds)
  return _internal_skillids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
S_LOAD_SKILL::_internal_mutable_skillids() {
  return &_impl_.skillids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
S_LOAD_SKILL::mutable_skillids() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_LOAD_SKILL.skillIds)
  return _internal_mutable_skillids();
}

// repeated int32 skillLevels = 2;
inline int S_LOAD_SKILL::_internal_skilllevels_size() const {
  return _impl_.skilllevels_.size();
}
inline int S_LOAD_SKILL::skilllevels_size() const {
  return _internal_skilllevels_size();
}
inline void S_LOAD_SKILL::clear_skilllevels() {
  _impl_.skilllevels_.Clear();
}
inline int32_t S_LOAD_SKILL::_internal_skilllevels(int index) const {
  return _impl_.skilllevels_.Get(index);
}
inline int32_t S_LOAD_SKILL::skilllevels(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_LOAD_SKILL.skillLevels)
  return _internal_skilllevels(index);
}
inline void S_LOAD_SKILL::set_skilllevels(int index, int32_t value) {
  _impl_.skilllevels_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.S_LOAD_SKILL.skillLevels)
}
inline void S_LOAD_SKILL::_internal_add_skilllevels(int32_t value) {
  _impl_.skilllevels_.Add(value);
}
inline void S_LOAD_SKILL::add_skilllevels(int32_t value) {
  _internal_add_skilllevels(value);
  // @@protoc_insertion_point(field_add:Protocol.S_LOAD_SKILL.skillLevels)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
S_LOAD_SKILL::_internal_skilllevels() const {
  return _impl_.skilllevels_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
S_LOAD_SKILL::skilllevels() const {
  // @@protoc_insertion_point(field_list:Protocol.S_LOAD_SKILL.skillLevels)
  return _internal_skilllevels();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
S_LOAD_SKILL::_internal_mutable_skilllevels() {
  return &_impl_.skilllevels_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
S_LOAD_SKILL::mutable_skilllevels() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_LOAD_SKILL.skillLevels)
  return _internal_mutable_skilllevels();
}

// -------------------------------------------------------------------

// S_LOAD_QUICK

// repeated .Protocol.EQuickSlot slot = 1;
inline int S_LOAD_QUICK::_internal_slot_size() const {
  return _impl_.slot_.size();
}
inline int S_LOAD_QUICK::slot_size() const {
  return _internal_slot_size();
}
inline void S_LOAD_QUICK::clear_slot() {
  _impl_.slot_.Clear();
}
inline ::Protocol::EQuickSlot S_LOAD_QUICK::_internal_slot(int index) const {
  return static_cast< ::Protocol::EQuickSlot >(_impl_.slot_.Get(index));
}
inline ::Protocol::EQuickSlot S_LOAD_QUICK::slot(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_LOAD_QUICK.slot)
  return _internal_slot(index);
}
inline void S_LOAD_QUICK::set_slot(int index, ::Protocol::EQuickSlot value) {
  _impl_.slot_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.S_LOAD_QUICK.slot)
}
inline void S_LOAD_QUICK::_internal_add_slot(::Protocol::EQuickSlot value) {
  _impl_.slot_.Add(value);
}
inline void S_LOAD_QUICK::add_slot(::Protocol::EQuickSlot value) {
  _internal_add_slot(value);
  // @@protoc_insertion_point(field_add:Protocol.S_LOAD_QUICK.slot)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
S_LOAD_QUICK::slot() const {
  // @@protoc_insertion_point(field_list:Protocol.S_LOAD_QUICK.slot)
  return _impl_.slot_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
S_LOAD_QUICK::_internal_mutable_slot() {
  return &_impl_.slot_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
S_LOAD_QUICK::mutable_slot() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_LOAD_QUICK.slot)
  return _internal_mutable_slot();
}

// repeated .Protocol.EQuickElementType type = 2;
inline int S_LOAD_QUICK::_internal_type_size() const {
  return _impl_.type_.size();
}
inline int S_LOAD_QUICK::type_size() const {
  return _internal_type_size();
}
inline void S_LOAD_QUICK::clear_type() {
  _impl_.type_.Clear();
}
inline ::Protocol::EQuickElementType S_LOAD_QUICK::_internal_type(int index) const {
  return static_cast< ::Protocol::EQuickElementType >(_impl_.type_.Get(index));
}
inline ::Protocol::EQuickElementType S_LOAD_QUICK::type(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_LOAD_QUICK.type)
  return _internal_type(index);
}
inline void S_LOAD_QUICK::set_type(int index, ::Protocol::EQuickElementType value) {
  _impl_.type_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.S_LOAD_QUICK.type)
}
inline void S_LOAD_QUICK::_internal_add_type(::Protocol::EQuickElementType value) {
  _impl_.type_.Add(value);
}
inline void S_LOAD_QUICK::add_type(::Protocol::EQuickElementType value) {
  _internal_add_type(value);
  // @@protoc_insertion_point(field_add:Protocol.S_LOAD_QUICK.type)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
S_LOAD_QUICK::type() const {
  // @@protoc_insertion_point(field_list:Protocol.S_LOAD_QUICK.type)
  return _impl_.type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
S_LOAD_QUICK::_internal_mutable_type() {
  return &_impl_.type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
S_LOAD_QUICK::mutable_type() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_LOAD_QUICK.type)
  return _internal_mutable_type();
}

// repeated uint64 elementId = 3;
inline int S_LOAD_QUICK::_internal_elementid_size() const {
  return _impl_.elementid_.size();
}
inline int S_LOAD_QUICK::elementid_size() const {
  return _internal_elementid_size();
}
inline void S_LOAD_QUICK::clear_elementid() {
  _impl_.elementid_.Clear();
}
inline uint64_t S_LOAD_QUICK::_internal_elementid(int index) const {
  return _impl_.elementid_.Get(index);
}
inline uint64_t S_LOAD_QUICK::elementid(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_LOAD_QUICK.elementId)
  return _internal_elementid(index);
}
inline void S_LOAD_QUICK::set_elementid(int index, uint64_t value) {
  _impl_.elementid_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.S_LOAD_QUICK.elementId)
}
inline void S_LOAD_QUICK::_internal_add_elementid(uint64_t value) {
  _impl_.elementid_.Add(value);
}
inline void S_LOAD_QUICK::add_elementid(uint64_t value) {
  _internal_add_elementid(value);
  // @@protoc_insertion_point(field_add:Protocol.S_LOAD_QUICK.elementId)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
S_LOAD_QUICK::_internal_elementid() const {
  return _impl_.elementid_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
S_LOAD_QUICK::elementid() const {
  // @@protoc_insertion_point(field_list:Protocol.S_LOAD_QUICK.elementId)
  return _internal_elementid();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
S_LOAD_QUICK::_internal_mutable_elementid() {
  return &_impl_.elementid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
S_LOAD_QUICK::mutable_elementid() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_LOAD_QUICK.elementId)
  return _internal_mutable_elementid();
}

// -------------------------------------------------------------------

// C_LEAVE_GAME

// -------------------------------------------------------------------

// S_LEAVE_GAME

// -------------------------------------------------------------------

// S_SPAWN

// repeated .Protocol.ObjectInfo players = 1;
inline int S_SPAWN::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int S_SPAWN::players_size() const {
  return _internal_players_size();
}
inline ::Protocol::ObjectInfo* S_SPAWN::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_SPAWN.players)
  return _impl_.players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >*
S_SPAWN::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_SPAWN.players)
  return &_impl_.players_;
}
inline const ::Protocol::ObjectInfo& S_SPAWN::_internal_players(int index) const {
  return _impl_.players_.Get(index);
}
inline const ::Protocol::ObjectInfo& S_SPAWN::players(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_SPAWN.players)
  return _internal_players(index);
}
inline ::Protocol::ObjectInfo* S_SPAWN::_internal_add_players() {
  return _impl_.players_.Add();
}
inline ::Protocol::ObjectInfo* S_SPAWN::add_players() {
  ::Protocol::ObjectInfo* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:Protocol.S_SPAWN.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ObjectInfo >&
S_SPAWN::players() const {
  // @@protoc_insertion_point(field_list:Protocol.S_SPAWN.players)
  return _impl_.players_;
}

// repeated .Protocol.StatInfo stats = 2;
inline int S_SPAWN::_internal_stats_size() const {
  return _impl_.stats_.size();
}
inline int S_SPAWN::stats_size() const {
  return _internal_stats_size();
}
inline ::Protocol::StatInfo* S_SPAWN::mutable_stats(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_SPAWN.stats)
  return _impl_.stats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::StatInfo >*
S_SPAWN::mutable_stats() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_SPAWN.stats)
  return &_impl_.stats_;
}
inline const ::Protocol::StatInfo& S_SPAWN::_internal_stats(int index) const {
  return _impl_.stats_.Get(index);
}
inline const ::Protocol::StatInfo& S_SPAWN::stats(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_SPAWN.stats)
  return _internal_stats(index);
}
inline ::Protocol::StatInfo* S_SPAWN::_internal_add_stats() {
  return _impl_.stats_.Add();
}
inline ::Protocol::StatInfo* S_SPAWN::add_stats() {
  ::Protocol::StatInfo* _add = _internal_add_stats();
  // @@protoc_insertion_point(field_add:Protocol.S_SPAWN.stats)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::StatInfo >&
S_SPAWN::stats() const {
  // @@protoc_insertion_point(field_list:Protocol.S_SPAWN.stats)
  return _impl_.stats_;
}

// repeated string playerName = 3;
inline int S_SPAWN::_internal_playername_size() const {
  return _impl_.playername_.size();
}
inline int S_SPAWN::playername_size() const {
  return _internal_playername_size();
}
inline void S_SPAWN::clear_playername() {
  _impl_.playername_.Clear();
}
inline std::string* S_SPAWN::add_playername() {
  std::string* _s = _internal_add_playername();
  // @@protoc_insertion_point(field_add_mutable:Protocol.S_SPAWN.playerName)
  return _s;
}
inline const std::string& S_SPAWN::_internal_playername(int index) const {
  return _impl_.playername_.Get(index);
}
inline const std::string& S_SPAWN::playername(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_SPAWN.playerName)
  return _internal_playername(index);
}
inline std::string* S_SPAWN::mutable_playername(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S_SPAWN.playerName)
  return _impl_.playername_.Mutable(index);
}
inline void S_SPAWN::set_playername(int index, const std::string& value) {
  _impl_.playername_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SPAWN.playerName)
}
inline void S_SPAWN::set_playername(int index, std::string&& value) {
  _impl_.playername_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Protocol.S_SPAWN.playerName)
}
inline void S_SPAWN::set_playername(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.playername_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Protocol.S_SPAWN.playerName)
}
inline void S_SPAWN::set_playername(int index, const char* value, size_t size) {
  _impl_.playername_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Protocol.S_SPAWN.playerName)
}
inline std::string* S_SPAWN::_internal_add_playername() {
  return _impl_.playername_.Add();
}
inline void S_SPAWN::add_playername(const std::string& value) {
  _impl_.playername_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Protocol.S_SPAWN.playerName)
}
inline void S_SPAWN::add_playername(std::string&& value) {
  _impl_.playername_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Protocol.S_SPAWN.playerName)
}
inline void S_SPAWN::add_playername(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.playername_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Protocol.S_SPAWN.playerName)
}
inline void S_SPAWN::add_playername(const char* value, size_t size) {
  _impl_.playername_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Protocol.S_SPAWN.playerName)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
S_SPAWN::playername() const {
  // @@protoc_insertion_point(field_list:Protocol.S_SPAWN.playerName)
  return _impl_.playername_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
S_SPAWN::mutable_playername() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_SPAWN.playerName)
  return &_impl_.playername_;
}

// -------------------------------------------------------------------

// S_DESPAWN

// repeated uint64 object_ids = 1;
inline int S_DESPAWN::_internal_object_ids_size() const {
  return _impl_.object_ids_.size();
}
inline int S_DESPAWN::object_ids_size() const {
  return _internal_object_ids_size();
}
inline void S_DESPAWN::clear_object_ids() {
  _impl_.object_ids_.Clear();
}
inline uint64_t S_DESPAWN::_internal_object_ids(int index) const {
  return _impl_.object_ids_.Get(index);
}
inline uint64_t S_DESPAWN::object_ids(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_DESPAWN.object_ids)
  return _internal_object_ids(index);
}
inline void S_DESPAWN::set_object_ids(int index, uint64_t value) {
  _impl_.object_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.S_DESPAWN.object_ids)
}
inline void S_DESPAWN::_internal_add_object_ids(uint64_t value) {
  _impl_.object_ids_.Add(value);
}
inline void S_DESPAWN::add_object_ids(uint64_t value) {
  _internal_add_object_ids(value);
  // @@protoc_insertion_point(field_add:Protocol.S_DESPAWN.object_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
S_DESPAWN::_internal_object_ids() const {
  return _impl_.object_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
S_DESPAWN::object_ids() const {
  // @@protoc_insertion_point(field_list:Protocol.S_DESPAWN.object_ids)
  return _internal_object_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
S_DESPAWN::_internal_mutable_object_ids() {
  return &_impl_.object_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
S_DESPAWN::mutable_object_ids() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_DESPAWN.object_ids)
  return _internal_mutable_object_ids();
}

// -------------------------------------------------------------------

// C_MOVE

// .Protocol.ObjectInfo info = 1;
inline bool C_MOVE::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool C_MOVE::has_info() const {
  return _internal_has_info();
}
inline const ::Protocol::ObjectInfo& C_MOVE::_internal_info() const {
  const ::Protocol::ObjectInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& C_MOVE::info() const {
  // @@protoc_insertion_point(field_get:Protocol.C_MOVE.info)
  return _internal_info();
}
inline void C_MOVE::unsafe_arena_set_allocated_info(
    ::Protocol::ObjectInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_MOVE.info)
}
inline ::Protocol::ObjectInfo* C_MOVE::release_info() {
  
  ::Protocol::ObjectInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ObjectInfo* C_MOVE::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:Protocol.C_MOVE.info)
  
  ::Protocol::ObjectInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* C_MOVE::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::Protocol::ObjectInfo* C_MOVE::mutable_info() {
  ::Protocol::ObjectInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:Protocol.C_MOVE.info)
  return _msg;
}
inline void C_MOVE::set_allocated_info(::Protocol::ObjectInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_MOVE.info)
}

// .Protocol.PlayerMoveInfo playerInfo = 2;
inline bool C_MOVE::_internal_has_playerinfo() const {
  return this != internal_default_instance() && _impl_.playerinfo_ != nullptr;
}
inline bool C_MOVE::has_playerinfo() const {
  return _internal_has_playerinfo();
}
inline const ::Protocol::PlayerMoveInfo& C_MOVE::_internal_playerinfo() const {
  const ::Protocol::PlayerMoveInfo* p = _impl_.playerinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PlayerMoveInfo&>(
      ::Protocol::_PlayerMoveInfo_default_instance_);
}
inline const ::Protocol::PlayerMoveInfo& C_MOVE::playerinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.C_MOVE.playerInfo)
  return _internal_playerinfo();
}
inline void C_MOVE::unsafe_arena_set_allocated_playerinfo(
    ::Protocol::PlayerMoveInfo* playerinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.playerinfo_);
  }
  _impl_.playerinfo_ = playerinfo;
  if (playerinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_MOVE.playerInfo)
}
inline ::Protocol::PlayerMoveInfo* C_MOVE::release_playerinfo() {
  
  ::Protocol::PlayerMoveInfo* temp = _impl_.playerinfo_;
  _impl_.playerinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PlayerMoveInfo* C_MOVE::unsafe_arena_release_playerinfo() {
  // @@protoc_insertion_point(field_release:Protocol.C_MOVE.playerInfo)
  
  ::Protocol::PlayerMoveInfo* temp = _impl_.playerinfo_;
  _impl_.playerinfo_ = nullptr;
  return temp;
}
inline ::Protocol::PlayerMoveInfo* C_MOVE::_internal_mutable_playerinfo() {
  
  if (_impl_.playerinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PlayerMoveInfo>(GetArenaForAllocation());
    _impl_.playerinfo_ = p;
  }
  return _impl_.playerinfo_;
}
inline ::Protocol::PlayerMoveInfo* C_MOVE::mutable_playerinfo() {
  ::Protocol::PlayerMoveInfo* _msg = _internal_mutable_playerinfo();
  // @@protoc_insertion_point(field_mutable:Protocol.C_MOVE.playerInfo)
  return _msg;
}
inline void C_MOVE::set_allocated_playerinfo(::Protocol::PlayerMoveInfo* playerinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.playerinfo_);
  }
  if (playerinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerinfo));
    if (message_arena != submessage_arena) {
      playerinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.playerinfo_ = playerinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_MOVE.playerInfo)
}

// -------------------------------------------------------------------

// S_MOVE

// .Protocol.ObjectInfo info = 1;
inline bool S_MOVE::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool S_MOVE::has_info() const {
  return _internal_has_info();
}
inline const ::Protocol::ObjectInfo& S_MOVE::_internal_info() const {
  const ::Protocol::ObjectInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& S_MOVE::info() const {
  // @@protoc_insertion_point(field_get:Protocol.S_MOVE.info)
  return _internal_info();
}
inline void S_MOVE::unsafe_arena_set_allocated_info(
    ::Protocol::ObjectInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_MOVE.info)
}
inline ::Protocol::ObjectInfo* S_MOVE::release_info() {
  
  ::Protocol::ObjectInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ObjectInfo* S_MOVE::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:Protocol.S_MOVE.info)
  
  ::Protocol::ObjectInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* S_MOVE::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::Protocol::ObjectInfo* S_MOVE::mutable_info() {
  ::Protocol::ObjectInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:Protocol.S_MOVE.info)
  return _msg;
}
inline void S_MOVE::set_allocated_info(::Protocol::ObjectInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_MOVE.info)
}

// .Protocol.PlayerMoveInfo playerInfo = 2;
inline bool S_MOVE::_internal_has_playerinfo() const {
  return this != internal_default_instance() && _impl_.playerinfo_ != nullptr;
}
inline bool S_MOVE::has_playerinfo() const {
  return _internal_has_playerinfo();
}
inline const ::Protocol::PlayerMoveInfo& S_MOVE::_internal_playerinfo() const {
  const ::Protocol::PlayerMoveInfo* p = _impl_.playerinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PlayerMoveInfo&>(
      ::Protocol::_PlayerMoveInfo_default_instance_);
}
inline const ::Protocol::PlayerMoveInfo& S_MOVE::playerinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.S_MOVE.playerInfo)
  return _internal_playerinfo();
}
inline void S_MOVE::unsafe_arena_set_allocated_playerinfo(
    ::Protocol::PlayerMoveInfo* playerinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.playerinfo_);
  }
  _impl_.playerinfo_ = playerinfo;
  if (playerinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_MOVE.playerInfo)
}
inline ::Protocol::PlayerMoveInfo* S_MOVE::release_playerinfo() {
  
  ::Protocol::PlayerMoveInfo* temp = _impl_.playerinfo_;
  _impl_.playerinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PlayerMoveInfo* S_MOVE::unsafe_arena_release_playerinfo() {
  // @@protoc_insertion_point(field_release:Protocol.S_MOVE.playerInfo)
  
  ::Protocol::PlayerMoveInfo* temp = _impl_.playerinfo_;
  _impl_.playerinfo_ = nullptr;
  return temp;
}
inline ::Protocol::PlayerMoveInfo* S_MOVE::_internal_mutable_playerinfo() {
  
  if (_impl_.playerinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PlayerMoveInfo>(GetArenaForAllocation());
    _impl_.playerinfo_ = p;
  }
  return _impl_.playerinfo_;
}
inline ::Protocol::PlayerMoveInfo* S_MOVE::mutable_playerinfo() {
  ::Protocol::PlayerMoveInfo* _msg = _internal_mutable_playerinfo();
  // @@protoc_insertion_point(field_mutable:Protocol.S_MOVE.playerInfo)
  return _msg;
}
inline void S_MOVE::set_allocated_playerinfo(::Protocol::PlayerMoveInfo* playerinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.playerinfo_);
  }
  if (playerinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerinfo));
    if (message_arena != submessage_arena) {
      playerinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.playerinfo_ = playerinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_MOVE.playerInfo)
}

// -------------------------------------------------------------------

// C_ATTACK

// .Protocol.ObjectInfo info = 1;
inline bool C_ATTACK::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool C_ATTACK::has_info() const {
  return _internal_has_info();
}
inline const ::Protocol::ObjectInfo& C_ATTACK::_internal_info() const {
  const ::Protocol::ObjectInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& C_ATTACK::info() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ATTACK.info)
  return _internal_info();
}
inline void C_ATTACK::unsafe_arena_set_allocated_info(
    ::Protocol::ObjectInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_ATTACK.info)
}
inline ::Protocol::ObjectInfo* C_ATTACK::release_info() {
  
  ::Protocol::ObjectInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ObjectInfo* C_ATTACK::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:Protocol.C_ATTACK.info)
  
  ::Protocol::ObjectInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* C_ATTACK::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::Protocol::ObjectInfo* C_ATTACK::mutable_info() {
  ::Protocol::ObjectInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:Protocol.C_ATTACK.info)
  return _msg;
}
inline void C_ATTACK::set_allocated_info(::Protocol::ObjectInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_ATTACK.info)
}

// int32 attack_sequence = 2;
inline void C_ATTACK::clear_attack_sequence() {
  _impl_.attack_sequence_ = 0;
}
inline int32_t C_ATTACK::_internal_attack_sequence() const {
  return _impl_.attack_sequence_;
}
inline int32_t C_ATTACK::attack_sequence() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ATTACK.attack_sequence)
  return _internal_attack_sequence();
}
inline void C_ATTACK::_internal_set_attack_sequence(int32_t value) {
  
  _impl_.attack_sequence_ = value;
}
inline void C_ATTACK::set_attack_sequence(int32_t value) {
  _internal_set_attack_sequence(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ATTACK.attack_sequence)
}

// float x = 3;
inline void C_ATTACK::clear_x() {
  _impl_.x_ = 0;
}
inline float C_ATTACK::_internal_x() const {
  return _impl_.x_;
}
inline float C_ATTACK::x() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ATTACK.x)
  return _internal_x();
}
inline void C_ATTACK::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void C_ATTACK::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ATTACK.x)
}

// float y = 4;
inline void C_ATTACK::clear_y() {
  _impl_.y_ = 0;
}
inline float C_ATTACK::_internal_y() const {
  return _impl_.y_;
}
inline float C_ATTACK::y() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ATTACK.y)
  return _internal_y();
}
inline void C_ATTACK::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void C_ATTACK::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ATTACK.y)
}

// float z = 5;
inline void C_ATTACK::clear_z() {
  _impl_.z_ = 0;
}
inline float C_ATTACK::_internal_z() const {
  return _impl_.z_;
}
inline float C_ATTACK::z() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ATTACK.z)
  return _internal_z();
}
inline void C_ATTACK::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void C_ATTACK::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ATTACK.z)
}

// -------------------------------------------------------------------

// S_ATTACK

// .Protocol.ObjectInfo info = 1;
inline bool S_ATTACK::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool S_ATTACK::has_info() const {
  return _internal_has_info();
}
inline const ::Protocol::ObjectInfo& S_ATTACK::_internal_info() const {
  const ::Protocol::ObjectInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& S_ATTACK::info() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ATTACK.info)
  return _internal_info();
}
inline void S_ATTACK::unsafe_arena_set_allocated_info(
    ::Protocol::ObjectInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_ATTACK.info)
}
inline ::Protocol::ObjectInfo* S_ATTACK::release_info() {
  
  ::Protocol::ObjectInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ObjectInfo* S_ATTACK::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:Protocol.S_ATTACK.info)
  
  ::Protocol::ObjectInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* S_ATTACK::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::Protocol::ObjectInfo* S_ATTACK::mutable_info() {
  ::Protocol::ObjectInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:Protocol.S_ATTACK.info)
  return _msg;
}
inline void S_ATTACK::set_allocated_info(::Protocol::ObjectInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_ATTACK.info)
}

// int32 attack_sequence = 2;
inline void S_ATTACK::clear_attack_sequence() {
  _impl_.attack_sequence_ = 0;
}
inline int32_t S_ATTACK::_internal_attack_sequence() const {
  return _impl_.attack_sequence_;
}
inline int32_t S_ATTACK::attack_sequence() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ATTACK.attack_sequence)
  return _internal_attack_sequence();
}
inline void S_ATTACK::_internal_set_attack_sequence(int32_t value) {
  
  _impl_.attack_sequence_ = value;
}
inline void S_ATTACK::set_attack_sequence(int32_t value) {
  _internal_set_attack_sequence(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ATTACK.attack_sequence)
}

// float x = 3;
inline void S_ATTACK::clear_x() {
  _impl_.x_ = 0;
}
inline float S_ATTACK::_internal_x() const {
  return _impl_.x_;
}
inline float S_ATTACK::x() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ATTACK.x)
  return _internal_x();
}
inline void S_ATTACK::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void S_ATTACK::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ATTACK.x)
}

// float y = 4;
inline void S_ATTACK::clear_y() {
  _impl_.y_ = 0;
}
inline float S_ATTACK::_internal_y() const {
  return _impl_.y_;
}
inline float S_ATTACK::y() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ATTACK.y)
  return _internal_y();
}
inline void S_ATTACK::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void S_ATTACK::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ATTACK.y)
}

// float z = 5;
inline void S_ATTACK::clear_z() {
  _impl_.z_ = 0;
}
inline float S_ATTACK::_internal_z() const {
  return _impl_.z_;
}
inline float S_ATTACK::z() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ATTACK.z)
  return _internal_z();
}
inline void S_ATTACK::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void S_ATTACK::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ATTACK.z)
}

// -------------------------------------------------------------------

// C_USESKILL

// .Protocol.ObjectInfo info = 1;
inline bool C_USESKILL::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool C_USESKILL::has_info() const {
  return _internal_has_info();
}
inline const ::Protocol::ObjectInfo& C_USESKILL::_internal_info() const {
  const ::Protocol::ObjectInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& C_USESKILL::info() const {
  // @@protoc_insertion_point(field_get:Protocol.C_USESKILL.info)
  return _internal_info();
}
inline void C_USESKILL::unsafe_arena_set_allocated_info(
    ::Protocol::ObjectInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.C_USESKILL.info)
}
inline ::Protocol::ObjectInfo* C_USESKILL::release_info() {
  
  ::Protocol::ObjectInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ObjectInfo* C_USESKILL::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:Protocol.C_USESKILL.info)
  
  ::Protocol::ObjectInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* C_USESKILL::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::Protocol::ObjectInfo* C_USESKILL::mutable_info() {
  ::Protocol::ObjectInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:Protocol.C_USESKILL.info)
  return _msg;
}
inline void C_USESKILL::set_allocated_info(::Protocol::ObjectInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_USESKILL.info)
}

// int32 SkillId = 2;
inline void C_USESKILL::clear_skillid() {
  _impl_.skillid_ = 0;
}
inline int32_t C_USESKILL::_internal_skillid() const {
  return _impl_.skillid_;
}
inline int32_t C_USESKILL::skillid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_USESKILL.SkillId)
  return _internal_skillid();
}
inline void C_USESKILL::_internal_set_skillid(int32_t value) {
  
  _impl_.skillid_ = value;
}
inline void C_USESKILL::set_skillid(int32_t value) {
  _internal_set_skillid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_USESKILL.SkillId)
}

// float x = 3;
inline void C_USESKILL::clear_x() {
  _impl_.x_ = 0;
}
inline float C_USESKILL::_internal_x() const {
  return _impl_.x_;
}
inline float C_USESKILL::x() const {
  // @@protoc_insertion_point(field_get:Protocol.C_USESKILL.x)
  return _internal_x();
}
inline void C_USESKILL::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void C_USESKILL::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.C_USESKILL.x)
}

// float y = 4;
inline void C_USESKILL::clear_y() {
  _impl_.y_ = 0;
}
inline float C_USESKILL::_internal_y() const {
  return _impl_.y_;
}
inline float C_USESKILL::y() const {
  // @@protoc_insertion_point(field_get:Protocol.C_USESKILL.y)
  return _internal_y();
}
inline void C_USESKILL::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void C_USESKILL::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.C_USESKILL.y)
}

// float z = 5;
inline void C_USESKILL::clear_z() {
  _impl_.z_ = 0;
}
inline float C_USESKILL::_internal_z() const {
  return _impl_.z_;
}
inline float C_USESKILL::z() const {
  // @@protoc_insertion_point(field_get:Protocol.C_USESKILL.z)
  return _internal_z();
}
inline void C_USESKILL::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void C_USESKILL::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Protocol.C_USESKILL.z)
}

// -------------------------------------------------------------------

// S_USESKILL

// .Protocol.ObjectInfo info = 1;
inline bool S_USESKILL::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool S_USESKILL::has_info() const {
  return _internal_has_info();
}
inline const ::Protocol::ObjectInfo& S_USESKILL::_internal_info() const {
  const ::Protocol::ObjectInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& S_USESKILL::info() const {
  // @@protoc_insertion_point(field_get:Protocol.S_USESKILL.info)
  return _internal_info();
}
inline void S_USESKILL::unsafe_arena_set_allocated_info(
    ::Protocol::ObjectInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_USESKILL.info)
}
inline ::Protocol::ObjectInfo* S_USESKILL::release_info() {
  
  ::Protocol::ObjectInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ObjectInfo* S_USESKILL::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:Protocol.S_USESKILL.info)
  
  ::Protocol::ObjectInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* S_USESKILL::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::Protocol::ObjectInfo* S_USESKILL::mutable_info() {
  ::Protocol::ObjectInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:Protocol.S_USESKILL.info)
  return _msg;
}
inline void S_USESKILL::set_allocated_info(::Protocol::ObjectInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_USESKILL.info)
}

// int32 SkillId = 2;
inline void S_USESKILL::clear_skillid() {
  _impl_.skillid_ = 0;
}
inline int32_t S_USESKILL::_internal_skillid() const {
  return _impl_.skillid_;
}
inline int32_t S_USESKILL::skillid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_USESKILL.SkillId)
  return _internal_skillid();
}
inline void S_USESKILL::_internal_set_skillid(int32_t value) {
  
  _impl_.skillid_ = value;
}
inline void S_USESKILL::set_skillid(int32_t value) {
  _internal_set_skillid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_USESKILL.SkillId)
}

// float x = 3;
inline void S_USESKILL::clear_x() {
  _impl_.x_ = 0;
}
inline float S_USESKILL::_internal_x() const {
  return _impl_.x_;
}
inline float S_USESKILL::x() const {
  // @@protoc_insertion_point(field_get:Protocol.S_USESKILL.x)
  return _internal_x();
}
inline void S_USESKILL::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void S_USESKILL::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.S_USESKILL.x)
}

// float y = 4;
inline void S_USESKILL::clear_y() {
  _impl_.y_ = 0;
}
inline float S_USESKILL::_internal_y() const {
  return _impl_.y_;
}
inline float S_USESKILL::y() const {
  // @@protoc_insertion_point(field_get:Protocol.S_USESKILL.y)
  return _internal_y();
}
inline void S_USESKILL::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void S_USESKILL::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.S_USESKILL.y)
}

// float z = 5;
inline void S_USESKILL::clear_z() {
  _impl_.z_ = 0;
}
inline float S_USESKILL::_internal_z() const {
  return _impl_.z_;
}
inline float S_USESKILL::z() const {
  // @@protoc_insertion_point(field_get:Protocol.S_USESKILL.z)
  return _internal_z();
}
inline void S_USESKILL::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void S_USESKILL::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Protocol.S_USESKILL.z)
}

// int32 coolDown = 6;
inline void S_USESKILL::clear_cooldown() {
  _impl_.cooldown_ = 0;
}
inline int32_t S_USESKILL::_internal_cooldown() const {
  return _impl_.cooldown_;
}
inline int32_t S_USESKILL::cooldown() const {
  // @@protoc_insertion_point(field_get:Protocol.S_USESKILL.coolDown)
  return _internal_cooldown();
}
inline void S_USESKILL::_internal_set_cooldown(int32_t value) {
  
  _impl_.cooldown_ = value;
}
inline void S_USESKILL::set_cooldown(int32_t value) {
  _internal_set_cooldown(value);
  // @@protoc_insertion_point(field_set:Protocol.S_USESKILL.coolDown)
}

// -------------------------------------------------------------------

// S_DAMAGED

// .Protocol.ObjectInfo info = 1;
inline bool S_DAMAGED::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool S_DAMAGED::has_info() const {
  return _internal_has_info();
}
inline const ::Protocol::ObjectInfo& S_DAMAGED::_internal_info() const {
  const ::Protocol::ObjectInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& S_DAMAGED::info() const {
  // @@protoc_insertion_point(field_get:Protocol.S_DAMAGED.info)
  return _internal_info();
}
inline void S_DAMAGED::unsafe_arena_set_allocated_info(
    ::Protocol::ObjectInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_DAMAGED.info)
}
inline ::Protocol::ObjectInfo* S_DAMAGED::release_info() {
  
  ::Protocol::ObjectInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ObjectInfo* S_DAMAGED::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:Protocol.S_DAMAGED.info)
  
  ::Protocol::ObjectInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* S_DAMAGED::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::Protocol::ObjectInfo* S_DAMAGED::mutable_info() {
  ::Protocol::ObjectInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:Protocol.S_DAMAGED.info)
  return _msg;
}
inline void S_DAMAGED::set_allocated_info(::Protocol::ObjectInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_DAMAGED.info)
}

// int32 damage = 2;
inline void S_DAMAGED::clear_damage() {
  _impl_.damage_ = 0;
}
inline int32_t S_DAMAGED::_internal_damage() const {
  return _impl_.damage_;
}
inline int32_t S_DAMAGED::damage() const {
  // @@protoc_insertion_point(field_get:Protocol.S_DAMAGED.damage)
  return _internal_damage();
}
inline void S_DAMAGED::_internal_set_damage(int32_t value) {
  
  _impl_.damage_ = value;
}
inline void S_DAMAGED::set_damage(int32_t value) {
  _internal_set_damage(value);
  // @@protoc_insertion_point(field_set:Protocol.S_DAMAGED.damage)
}

// uint64 attackerId = 3;
inline void S_DAMAGED::clear_attackerid() {
  _impl_.attackerid_ = uint64_t{0u};
}
inline uint64_t S_DAMAGED::_internal_attackerid() const {
  return _impl_.attackerid_;
}
inline uint64_t S_DAMAGED::attackerid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_DAMAGED.attackerId)
  return _internal_attackerid();
}
inline void S_DAMAGED::_internal_set_attackerid(uint64_t value) {
  
  _impl_.attackerid_ = value;
}
inline void S_DAMAGED::set_attackerid(uint64_t value) {
  _internal_set_attackerid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_DAMAGED.attackerId)
}

// -------------------------------------------------------------------

// S_DIE

// .Protocol.ObjectInfo info = 1;
inline bool S_DIE::_internal_has_info() const {
  return this != internal_default_instance() && _impl_.info_ != nullptr;
}
inline bool S_DIE::has_info() const {
  return _internal_has_info();
}
inline const ::Protocol::ObjectInfo& S_DIE::_internal_info() const {
  const ::Protocol::ObjectInfo* p = _impl_.info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ObjectInfo&>(
      ::Protocol::_ObjectInfo_default_instance_);
}
inline const ::Protocol::ObjectInfo& S_DIE::info() const {
  // @@protoc_insertion_point(field_get:Protocol.S_DIE.info)
  return _internal_info();
}
inline void S_DIE::unsafe_arena_set_allocated_info(
    ::Protocol::ObjectInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  _impl_.info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_DIE.info)
}
inline ::Protocol::ObjectInfo* S_DIE::release_info() {
  
  ::Protocol::ObjectInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ObjectInfo* S_DIE::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:Protocol.S_DIE.info)
  
  ::Protocol::ObjectInfo* temp = _impl_.info_;
  _impl_.info_ = nullptr;
  return temp;
}
inline ::Protocol::ObjectInfo* S_DIE::_internal_mutable_info() {
  
  if (_impl_.info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ObjectInfo>(GetArenaForAllocation());
    _impl_.info_ = p;
  }
  return _impl_.info_;
}
inline ::Protocol::ObjectInfo* S_DIE::mutable_info() {
  ::Protocol::ObjectInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:Protocol.S_DIE.info)
  return _msg;
}
inline void S_DIE::set_allocated_info(::Protocol::ObjectInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.info_ = info;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_DIE.info)
}

// -------------------------------------------------------------------

// C_CHAT

// string msg = 1;
inline void C_CHAT::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& C_CHAT::msg() const {
  // @@protoc_insertion_point(field_get:Protocol.C_CHAT.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C_CHAT::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C_CHAT.msg)
}
inline std::string* C_CHAT::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:Protocol.C_CHAT.msg)
  return _s;
}
inline const std::string& C_CHAT::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void C_CHAT::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* C_CHAT::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* C_CHAT::release_msg() {
  // @@protoc_insertion_point(field_release:Protocol.C_CHAT.msg)
  return _impl_.msg_.Release();
}
inline void C_CHAT::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C_CHAT.msg)
}

// -------------------------------------------------------------------

// S_CHAT

// uint64 playerId = 1;
inline void S_CHAT::clear_playerid() {
  _impl_.playerid_ = uint64_t{0u};
}
inline uint64_t S_CHAT::_internal_playerid() const {
  return _impl_.playerid_;
}
inline uint64_t S_CHAT::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CHAT.playerId)
  return _internal_playerid();
}
inline void S_CHAT::_internal_set_playerid(uint64_t value) {
  
  _impl_.playerid_ = value;
}
inline void S_CHAT::set_playerid(uint64_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_CHAT.playerId)
}

// string msg = 2;
inline void S_CHAT::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& S_CHAT::msg() const {
  // @@protoc_insertion_point(field_get:Protocol.S_CHAT.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S_CHAT::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S_CHAT.msg)
}
inline std::string* S_CHAT::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:Protocol.S_CHAT.msg)
  return _s;
}
inline const std::string& S_CHAT::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void S_CHAT::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* S_CHAT::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* S_CHAT::release_msg() {
  // @@protoc_insertion_point(field_release:Protocol.S_CHAT.msg)
  return _impl_.msg_.Release();
}
inline void S_CHAT::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_CHAT.msg)
}

// -------------------------------------------------------------------

// C_SETGOLD

// uint64 object_id = 1;
inline void C_SETGOLD::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_SETGOLD::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_SETGOLD::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SETGOLD.object_id)
  return _internal_object_id();
}
inline void C_SETGOLD::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_SETGOLD::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_SETGOLD.object_id)
}

// int32 gold = 2;
inline void C_SETGOLD::clear_gold() {
  _impl_.gold_ = 0;
}
inline int32_t C_SETGOLD::_internal_gold() const {
  return _impl_.gold_;
}
inline int32_t C_SETGOLD::gold() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SETGOLD.gold)
  return _internal_gold();
}
inline void C_SETGOLD::_internal_set_gold(int32_t value) {
  
  _impl_.gold_ = value;
}
inline void C_SETGOLD::set_gold(int32_t value) {
  _internal_set_gold(value);
  // @@protoc_insertion_point(field_set:Protocol.C_SETGOLD.gold)
}

// -------------------------------------------------------------------

// S_SETGOLD

// uint64 object_id = 1;
inline void S_SETGOLD::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_SETGOLD::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_SETGOLD::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SETGOLD.object_id)
  return _internal_object_id();
}
inline void S_SETGOLD::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_SETGOLD::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SETGOLD.object_id)
}

// int32 gold = 2;
inline void S_SETGOLD::clear_gold() {
  _impl_.gold_ = 0;
}
inline int32_t S_SETGOLD::_internal_gold() const {
  return _impl_.gold_;
}
inline int32_t S_SETGOLD::gold() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SETGOLD.gold)
  return _internal_gold();
}
inline void S_SETGOLD::_internal_set_gold(int32_t value) {
  
  _impl_.gold_ = value;
}
inline void S_SETGOLD::set_gold(int32_t value) {
  _internal_set_gold(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SETGOLD.gold)
}

// -------------------------------------------------------------------

// C_ADDITEM

// uint32 templateId = 1;
inline void C_ADDITEM::clear_templateid() {
  _impl_.templateid_ = 0u;
}
inline uint32_t C_ADDITEM::_internal_templateid() const {
  return _impl_.templateid_;
}
inline uint32_t C_ADDITEM::templateid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ADDITEM.templateId)
  return _internal_templateid();
}
inline void C_ADDITEM::_internal_set_templateid(uint32_t value) {
  
  _impl_.templateid_ = value;
}
inline void C_ADDITEM::set_templateid(uint32_t value) {
  _internal_set_templateid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ADDITEM.templateId)
}

// .Protocol.EItemType itemType = 2;
inline void C_ADDITEM::clear_itemtype() {
  _impl_.itemtype_ = 0;
}
inline ::Protocol::EItemType C_ADDITEM::_internal_itemtype() const {
  return static_cast< ::Protocol::EItemType >(_impl_.itemtype_);
}
inline ::Protocol::EItemType C_ADDITEM::itemtype() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ADDITEM.itemType)
  return _internal_itemtype();
}
inline void C_ADDITEM::_internal_set_itemtype(::Protocol::EItemType value) {
  
  _impl_.itemtype_ = value;
}
inline void C_ADDITEM::set_itemtype(::Protocol::EItemType value) {
  _internal_set_itemtype(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ADDITEM.itemType)
}

// .Protocol.EGetItemType getType = 3;
inline void C_ADDITEM::clear_gettype() {
  _impl_.gettype_ = 0;
}
inline ::Protocol::EGetItemType C_ADDITEM::_internal_gettype() const {
  return static_cast< ::Protocol::EGetItemType >(_impl_.gettype_);
}
inline ::Protocol::EGetItemType C_ADDITEM::gettype() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ADDITEM.getType)
  return _internal_gettype();
}
inline void C_ADDITEM::_internal_set_gettype(::Protocol::EGetItemType value) {
  
  _impl_.gettype_ = value;
}
inline void C_ADDITEM::set_gettype(::Protocol::EGetItemType value) {
  _internal_set_gettype(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ADDITEM.getType)
}

// int32 count = 4;
inline void C_ADDITEM::clear_count() {
  _impl_.count_ = 0;
}
inline int32_t C_ADDITEM::_internal_count() const {
  return _impl_.count_;
}
inline int32_t C_ADDITEM::count() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ADDITEM.count)
  return _internal_count();
}
inline void C_ADDITEM::_internal_set_count(int32_t value) {
  
  _impl_.count_ = value;
}
inline void C_ADDITEM::set_count(int32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ADDITEM.count)
}

// -------------------------------------------------------------------

// S_ADDITEM

// .Protocol.ItemUpdateInfo item = 1;
inline bool S_ADDITEM::_internal_has_item() const {
  return this != internal_default_instance() && _impl_.item_ != nullptr;
}
inline bool S_ADDITEM::has_item() const {
  return _internal_has_item();
}
inline const ::Protocol::ItemUpdateInfo& S_ADDITEM::_internal_item() const {
  const ::Protocol::ItemUpdateInfo* p = _impl_.item_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::ItemUpdateInfo&>(
      ::Protocol::_ItemUpdateInfo_default_instance_);
}
inline const ::Protocol::ItemUpdateInfo& S_ADDITEM::item() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ADDITEM.item)
  return _internal_item();
}
inline void S_ADDITEM::unsafe_arena_set_allocated_item(
    ::Protocol::ItemUpdateInfo* item) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_);
  }
  _impl_.item_ = item;
  if (item) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_ADDITEM.item)
}
inline ::Protocol::ItemUpdateInfo* S_ADDITEM::release_item() {
  
  ::Protocol::ItemUpdateInfo* temp = _impl_.item_;
  _impl_.item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::ItemUpdateInfo* S_ADDITEM::unsafe_arena_release_item() {
  // @@protoc_insertion_point(field_release:Protocol.S_ADDITEM.item)
  
  ::Protocol::ItemUpdateInfo* temp = _impl_.item_;
  _impl_.item_ = nullptr;
  return temp;
}
inline ::Protocol::ItemUpdateInfo* S_ADDITEM::_internal_mutable_item() {
  
  if (_impl_.item_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::ItemUpdateInfo>(GetArenaForAllocation());
    _impl_.item_ = p;
  }
  return _impl_.item_;
}
inline ::Protocol::ItemUpdateInfo* S_ADDITEM::mutable_item() {
  ::Protocol::ItemUpdateInfo* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:Protocol.S_ADDITEM.item)
  return _msg;
}
inline void S_ADDITEM::set_allocated_item(::Protocol::ItemUpdateInfo* item) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.item_);
  }
  if (item) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(item));
    if (message_arena != submessage_arena) {
      item = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, item, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.item_ = item;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_ADDITEM.item)
}

// bool byUnequip = 2;
inline void S_ADDITEM::clear_byunequip() {
  _impl_.byunequip_ = false;
}
inline bool S_ADDITEM::_internal_byunequip() const {
  return _impl_.byunequip_;
}
inline bool S_ADDITEM::byunequip() const {
  // @@protoc_insertion_point(field_get:Protocol.S_ADDITEM.byUnequip)
  return _internal_byunequip();
}
inline void S_ADDITEM::_internal_set_byunequip(bool value) {
  
  _impl_.byunequip_ = value;
}
inline void S_ADDITEM::set_byunequip(bool value) {
  _internal_set_byunequip(value);
  // @@protoc_insertion_point(field_set:Protocol.S_ADDITEM.byUnequip)
}

// -------------------------------------------------------------------

// C_ITEMSWAP

// uint64 playerId = 1;
inline void C_ITEMSWAP::clear_playerid() {
  _impl_.playerid_ = uint64_t{0u};
}
inline uint64_t C_ITEMSWAP::_internal_playerid() const {
  return _impl_.playerid_;
}
inline uint64_t C_ITEMSWAP::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ITEMSWAP.playerId)
  return _internal_playerid();
}
inline void C_ITEMSWAP::_internal_set_playerid(uint64_t value) {
  
  _impl_.playerid_ = value;
}
inline void C_ITEMSWAP::set_playerid(uint64_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ITEMSWAP.playerId)
}

// uint64 item1_dbId = 2;
inline void C_ITEMSWAP::clear_item1_dbid() {
  _impl_.item1_dbid_ = uint64_t{0u};
}
inline uint64_t C_ITEMSWAP::_internal_item1_dbid() const {
  return _impl_.item1_dbid_;
}
inline uint64_t C_ITEMSWAP::item1_dbid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ITEMSWAP.item1_dbId)
  return _internal_item1_dbid();
}
inline void C_ITEMSWAP::_internal_set_item1_dbid(uint64_t value) {
  
  _impl_.item1_dbid_ = value;
}
inline void C_ITEMSWAP::set_item1_dbid(uint64_t value) {
  _internal_set_item1_dbid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ITEMSWAP.item1_dbId)
}

// int32 item1_slot = 3;
inline void C_ITEMSWAP::clear_item1_slot() {
  _impl_.item1_slot_ = 0;
}
inline int32_t C_ITEMSWAP::_internal_item1_slot() const {
  return _impl_.item1_slot_;
}
inline int32_t C_ITEMSWAP::item1_slot() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ITEMSWAP.item1_slot)
  return _internal_item1_slot();
}
inline void C_ITEMSWAP::_internal_set_item1_slot(int32_t value) {
  
  _impl_.item1_slot_ = value;
}
inline void C_ITEMSWAP::set_item1_slot(int32_t value) {
  _internal_set_item1_slot(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ITEMSWAP.item1_slot)
}

// uint64 item2_dbId = 4;
inline void C_ITEMSWAP::clear_item2_dbid() {
  _impl_.item2_dbid_ = uint64_t{0u};
}
inline uint64_t C_ITEMSWAP::_internal_item2_dbid() const {
  return _impl_.item2_dbid_;
}
inline uint64_t C_ITEMSWAP::item2_dbid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ITEMSWAP.item2_dbId)
  return _internal_item2_dbid();
}
inline void C_ITEMSWAP::_internal_set_item2_dbid(uint64_t value) {
  
  _impl_.item2_dbid_ = value;
}
inline void C_ITEMSWAP::set_item2_dbid(uint64_t value) {
  _internal_set_item2_dbid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ITEMSWAP.item2_dbId)
}

// int32 item2_slot = 5;
inline void C_ITEMSWAP::clear_item2_slot() {
  _impl_.item2_slot_ = 0;
}
inline int32_t C_ITEMSWAP::_internal_item2_slot() const {
  return _impl_.item2_slot_;
}
inline int32_t C_ITEMSWAP::item2_slot() const {
  // @@protoc_insertion_point(field_get:Protocol.C_ITEMSWAP.item2_slot)
  return _internal_item2_slot();
}
inline void C_ITEMSWAP::_internal_set_item2_slot(int32_t value) {
  
  _impl_.item2_slot_ = value;
}
inline void C_ITEMSWAP::set_item2_slot(int32_t value) {
  _internal_set_item2_slot(value);
  // @@protoc_insertion_point(field_set:Protocol.C_ITEMSWAP.item2_slot)
}

// -------------------------------------------------------------------

// C_SET_QUICK

// .Protocol.EQuickElementType type = 1;
inline void C_SET_QUICK::clear_type() {
  _impl_.type_ = 0;
}
inline ::Protocol::EQuickElementType C_SET_QUICK::_internal_type() const {
  return static_cast< ::Protocol::EQuickElementType >(_impl_.type_);
}
inline ::Protocol::EQuickElementType C_SET_QUICK::type() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SET_QUICK.type)
  return _internal_type();
}
inline void C_SET_QUICK::_internal_set_type(::Protocol::EQuickElementType value) {
  
  _impl_.type_ = value;
}
inline void C_SET_QUICK::set_type(::Protocol::EQuickElementType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Protocol.C_SET_QUICK.type)
}

// uint64 elementId = 2;
inline void C_SET_QUICK::clear_elementid() {
  _impl_.elementid_ = uint64_t{0u};
}
inline uint64_t C_SET_QUICK::_internal_elementid() const {
  return _impl_.elementid_;
}
inline uint64_t C_SET_QUICK::elementid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SET_QUICK.elementId)
  return _internal_elementid();
}
inline void C_SET_QUICK::_internal_set_elementid(uint64_t value) {
  
  _impl_.elementid_ = value;
}
inline void C_SET_QUICK::set_elementid(uint64_t value) {
  _internal_set_elementid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_SET_QUICK.elementId)
}

// .Protocol.EQuickSlot slot = 3;
inline void C_SET_QUICK::clear_slot() {
  _impl_.slot_ = 0;
}
inline ::Protocol::EQuickSlot C_SET_QUICK::_internal_slot() const {
  return static_cast< ::Protocol::EQuickSlot >(_impl_.slot_);
}
inline ::Protocol::EQuickSlot C_SET_QUICK::slot() const {
  // @@protoc_insertion_point(field_get:Protocol.C_SET_QUICK.slot)
  return _internal_slot();
}
inline void C_SET_QUICK::_internal_set_slot(::Protocol::EQuickSlot value) {
  
  _impl_.slot_ = value;
}
inline void C_SET_QUICK::set_slot(::Protocol::EQuickSlot value) {
  _internal_set_slot(value);
  // @@protoc_insertion_point(field_set:Protocol.C_SET_QUICK.slot)
}

// -------------------------------------------------------------------

// C_EQUIP

// uint64 itemId = 1;
inline void C_EQUIP::clear_itemid() {
  _impl_.itemid_ = uint64_t{0u};
}
inline uint64_t C_EQUIP::_internal_itemid() const {
  return _impl_.itemid_;
}
inline uint64_t C_EQUIP::itemid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_EQUIP.itemId)
  return _internal_itemid();
}
inline void C_EQUIP::_internal_set_itemid(uint64_t value) {
  
  _impl_.itemid_ = value;
}
inline void C_EQUIP::set_itemid(uint64_t value) {
  _internal_set_itemid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_EQUIP.itemId)
}

// -------------------------------------------------------------------

// S_EQUIP

// uint64 equipDbId = 1;
inline void S_EQUIP::clear_equipdbid() {
  _impl_.equipdbid_ = uint64_t{0u};
}
inline uint64_t S_EQUIP::_internal_equipdbid() const {
  return _impl_.equipdbid_;
}
inline uint64_t S_EQUIP::equipdbid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EQUIP.equipDbId)
  return _internal_equipdbid();
}
inline void S_EQUIP::_internal_set_equipdbid(uint64_t value) {
  
  _impl_.equipdbid_ = value;
}
inline void S_EQUIP::set_equipdbid(uint64_t value) {
  _internal_set_equipdbid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EQUIP.equipDbId)
}

// uint64 prevItemDbId = 2;
inline void S_EQUIP::clear_previtemdbid() {
  _impl_.previtemdbid_ = uint64_t{0u};
}
inline uint64_t S_EQUIP::_internal_previtemdbid() const {
  return _impl_.previtemdbid_;
}
inline uint64_t S_EQUIP::previtemdbid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EQUIP.prevItemDbId)
  return _internal_previtemdbid();
}
inline void S_EQUIP::_internal_set_previtemdbid(uint64_t value) {
  
  _impl_.previtemdbid_ = value;
}
inline void S_EQUIP::set_previtemdbid(uint64_t value) {
  _internal_set_previtemdbid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EQUIP.prevItemDbId)
}

// int32 prevItemSlotIndex = 3;
inline void S_EQUIP::clear_previtemslotindex() {
  _impl_.previtemslotindex_ = 0;
}
inline int32_t S_EQUIP::_internal_previtemslotindex() const {
  return _impl_.previtemslotindex_;
}
inline int32_t S_EQUIP::previtemslotindex() const {
  // @@protoc_insertion_point(field_get:Protocol.S_EQUIP.prevItemSlotIndex)
  return _internal_previtemslotindex();
}
inline void S_EQUIP::_internal_set_previtemslotindex(int32_t value) {
  
  _impl_.previtemslotindex_ = value;
}
inline void S_EQUIP::set_previtemslotindex(int32_t value) {
  _internal_set_previtemslotindex(value);
  // @@protoc_insertion_point(field_set:Protocol.S_EQUIP.prevItemSlotIndex)
}

// -------------------------------------------------------------------

// C_UNEQUIP

// uint64 itemId = 1;
inline void C_UNEQUIP::clear_itemid() {
  _impl_.itemid_ = uint64_t{0u};
}
inline uint64_t C_UNEQUIP::_internal_itemid() const {
  return _impl_.itemid_;
}
inline uint64_t C_UNEQUIP::itemid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_UNEQUIP.itemId)
  return _internal_itemid();
}
inline void C_UNEQUIP::_internal_set_itemid(uint64_t value) {
  
  _impl_.itemid_ = value;
}
inline void C_UNEQUIP::set_itemid(uint64_t value) {
  _internal_set_itemid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_UNEQUIP.itemId)
}

// -------------------------------------------------------------------

// S_SETITEMCOUNT

// repeated uint64 itemId = 1;
inline int S_SETITEMCOUNT::_internal_itemid_size() const {
  return _impl_.itemid_.size();
}
inline int S_SETITEMCOUNT::itemid_size() const {
  return _internal_itemid_size();
}
inline void S_SETITEMCOUNT::clear_itemid() {
  _impl_.itemid_.Clear();
}
inline uint64_t S_SETITEMCOUNT::_internal_itemid(int index) const {
  return _impl_.itemid_.Get(index);
}
inline uint64_t S_SETITEMCOUNT::itemid(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_SETITEMCOUNT.itemId)
  return _internal_itemid(index);
}
inline void S_SETITEMCOUNT::set_itemid(int index, uint64_t value) {
  _impl_.itemid_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.S_SETITEMCOUNT.itemId)
}
inline void S_SETITEMCOUNT::_internal_add_itemid(uint64_t value) {
  _impl_.itemid_.Add(value);
}
inline void S_SETITEMCOUNT::add_itemid(uint64_t value) {
  _internal_add_itemid(value);
  // @@protoc_insertion_point(field_add:Protocol.S_SETITEMCOUNT.itemId)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
S_SETITEMCOUNT::_internal_itemid() const {
  return _impl_.itemid_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
S_SETITEMCOUNT::itemid() const {
  // @@protoc_insertion_point(field_list:Protocol.S_SETITEMCOUNT.itemId)
  return _internal_itemid();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
S_SETITEMCOUNT::_internal_mutable_itemid() {
  return &_impl_.itemid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
S_SETITEMCOUNT::mutable_itemid() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_SETITEMCOUNT.itemId)
  return _internal_mutable_itemid();
}

// repeated uint32 itemCount = 2;
inline int S_SETITEMCOUNT::_internal_itemcount_size() const {
  return _impl_.itemcount_.size();
}
inline int S_SETITEMCOUNT::itemcount_size() const {
  return _internal_itemcount_size();
}
inline void S_SETITEMCOUNT::clear_itemcount() {
  _impl_.itemcount_.Clear();
}
inline uint32_t S_SETITEMCOUNT::_internal_itemcount(int index) const {
  return _impl_.itemcount_.Get(index);
}
inline uint32_t S_SETITEMCOUNT::itemcount(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_SETITEMCOUNT.itemCount)
  return _internal_itemcount(index);
}
inline void S_SETITEMCOUNT::set_itemcount(int index, uint32_t value) {
  _impl_.itemcount_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.S_SETITEMCOUNT.itemCount)
}
inline void S_SETITEMCOUNT::_internal_add_itemcount(uint32_t value) {
  _impl_.itemcount_.Add(value);
}
inline void S_SETITEMCOUNT::add_itemcount(uint32_t value) {
  _internal_add_itemcount(value);
  // @@protoc_insertion_point(field_add:Protocol.S_SETITEMCOUNT.itemCount)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
S_SETITEMCOUNT::_internal_itemcount() const {
  return _impl_.itemcount_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
S_SETITEMCOUNT::itemcount() const {
  // @@protoc_insertion_point(field_list:Protocol.S_SETITEMCOUNT.itemCount)
  return _internal_itemcount();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
S_SETITEMCOUNT::_internal_mutable_itemcount() {
  return &_impl_.itemcount_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
S_SETITEMCOUNT::mutable_itemcount() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_SETITEMCOUNT.itemCount)
  return _internal_mutable_itemcount();
}

// -------------------------------------------------------------------

// C_USEITEM

// uint64 itemId = 1;
inline void C_USEITEM::clear_itemid() {
  _impl_.itemid_ = uint64_t{0u};
}
inline uint64_t C_USEITEM::_internal_itemid() const {
  return _impl_.itemid_;
}
inline uint64_t C_USEITEM::itemid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_USEITEM.itemId)
  return _internal_itemid();
}
inline void C_USEITEM::_internal_set_itemid(uint64_t value) {
  
  _impl_.itemid_ = value;
}
inline void C_USEITEM::set_itemid(uint64_t value) {
  _internal_set_itemid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_USEITEM.itemId)
}

// -------------------------------------------------------------------

// C_REMOVEITEM

// repeated uint64 ItemId = 1;
inline int C_REMOVEITEM::_internal_itemid_size() const {
  return _impl_.itemid_.size();
}
inline int C_REMOVEITEM::itemid_size() const {
  return _internal_itemid_size();
}
inline void C_REMOVEITEM::clear_itemid() {
  _impl_.itemid_.Clear();
}
inline uint64_t C_REMOVEITEM::_internal_itemid(int index) const {
  return _impl_.itemid_.Get(index);
}
inline uint64_t C_REMOVEITEM::itemid(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.C_REMOVEITEM.ItemId)
  return _internal_itemid(index);
}
inline void C_REMOVEITEM::set_itemid(int index, uint64_t value) {
  _impl_.itemid_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.C_REMOVEITEM.ItemId)
}
inline void C_REMOVEITEM::_internal_add_itemid(uint64_t value) {
  _impl_.itemid_.Add(value);
}
inline void C_REMOVEITEM::add_itemid(uint64_t value) {
  _internal_add_itemid(value);
  // @@protoc_insertion_point(field_add:Protocol.C_REMOVEITEM.ItemId)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
C_REMOVEITEM::_internal_itemid() const {
  return _impl_.itemid_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
C_REMOVEITEM::itemid() const {
  // @@protoc_insertion_point(field_list:Protocol.C_REMOVEITEM.ItemId)
  return _internal_itemid();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
C_REMOVEITEM::_internal_mutable_itemid() {
  return &_impl_.itemid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
C_REMOVEITEM::mutable_itemid() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.C_REMOVEITEM.ItemId)
  return _internal_mutable_itemid();
}

// repeated int32 removeCount = 2;
inline int C_REMOVEITEM::_internal_removecount_size() const {
  return _impl_.removecount_.size();
}
inline int C_REMOVEITEM::removecount_size() const {
  return _internal_removecount_size();
}
inline void C_REMOVEITEM::clear_removecount() {
  _impl_.removecount_.Clear();
}
inline int32_t C_REMOVEITEM::_internal_removecount(int index) const {
  return _impl_.removecount_.Get(index);
}
inline int32_t C_REMOVEITEM::removecount(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.C_REMOVEITEM.removeCount)
  return _internal_removecount(index);
}
inline void C_REMOVEITEM::set_removecount(int index, int32_t value) {
  _impl_.removecount_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.C_REMOVEITEM.removeCount)
}
inline void C_REMOVEITEM::_internal_add_removecount(int32_t value) {
  _impl_.removecount_.Add(value);
}
inline void C_REMOVEITEM::add_removecount(int32_t value) {
  _internal_add_removecount(value);
  // @@protoc_insertion_point(field_add:Protocol.C_REMOVEITEM.removeCount)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
C_REMOVEITEM::_internal_removecount() const {
  return _impl_.removecount_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
C_REMOVEITEM::removecount() const {
  // @@protoc_insertion_point(field_list:Protocol.C_REMOVEITEM.removeCount)
  return _internal_removecount();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
C_REMOVEITEM::_internal_mutable_removecount() {
  return &_impl_.removecount_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
C_REMOVEITEM::mutable_removecount() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.C_REMOVEITEM.removeCount)
  return _internal_mutable_removecount();
}

// bool bSell = 3;
inline void C_REMOVEITEM::clear_bsell() {
  _impl_.bsell_ = false;
}
inline bool C_REMOVEITEM::_internal_bsell() const {
  return _impl_.bsell_;
}
inline bool C_REMOVEITEM::bsell() const {
  // @@protoc_insertion_point(field_get:Protocol.C_REMOVEITEM.bSell)
  return _internal_bsell();
}
inline void C_REMOVEITEM::_internal_set_bsell(bool value) {
  
  _impl_.bsell_ = value;
}
inline void C_REMOVEITEM::set_bsell(bool value) {
  _internal_set_bsell(value);
  // @@protoc_insertion_point(field_set:Protocol.C_REMOVEITEM.bSell)
}

// -------------------------------------------------------------------

// S_REMOVEITEM

// repeated uint64 itemId = 1;
inline int S_REMOVEITEM::_internal_itemid_size() const {
  return _impl_.itemid_.size();
}
inline int S_REMOVEITEM::itemid_size() const {
  return _internal_itemid_size();
}
inline void S_REMOVEITEM::clear_itemid() {
  _impl_.itemid_.Clear();
}
inline uint64_t S_REMOVEITEM::_internal_itemid(int index) const {
  return _impl_.itemid_.Get(index);
}
inline uint64_t S_REMOVEITEM::itemid(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_REMOVEITEM.itemId)
  return _internal_itemid(index);
}
inline void S_REMOVEITEM::set_itemid(int index, uint64_t value) {
  _impl_.itemid_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.S_REMOVEITEM.itemId)
}
inline void S_REMOVEITEM::_internal_add_itemid(uint64_t value) {
  _impl_.itemid_.Add(value);
}
inline void S_REMOVEITEM::add_itemid(uint64_t value) {
  _internal_add_itemid(value);
  // @@protoc_insertion_point(field_add:Protocol.S_REMOVEITEM.itemId)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
S_REMOVEITEM::_internal_itemid() const {
  return _impl_.itemid_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
S_REMOVEITEM::itemid() const {
  // @@protoc_insertion_point(field_list:Protocol.S_REMOVEITEM.itemId)
  return _internal_itemid();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
S_REMOVEITEM::_internal_mutable_itemid() {
  return &_impl_.itemid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
S_REMOVEITEM::mutable_itemid() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_REMOVEITEM.itemId)
  return _internal_mutable_itemid();
}

// -------------------------------------------------------------------

// S_STATCHANGED

// uint64 object_id = 1;
inline void S_STATCHANGED::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_STATCHANGED::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_STATCHANGED::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_STATCHANGED.object_id)
  return _internal_object_id();
}
inline void S_STATCHANGED::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_STATCHANGED::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_STATCHANGED.object_id)
}

// .Protocol.StatInfo statInfo = 2;
inline bool S_STATCHANGED::_internal_has_statinfo() const {
  return this != internal_default_instance() && _impl_.statinfo_ != nullptr;
}
inline bool S_STATCHANGED::has_statinfo() const {
  return _internal_has_statinfo();
}
inline const ::Protocol::StatInfo& S_STATCHANGED::_internal_statinfo() const {
  const ::Protocol::StatInfo* p = _impl_.statinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::StatInfo&>(
      ::Protocol::_StatInfo_default_instance_);
}
inline const ::Protocol::StatInfo& S_STATCHANGED::statinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.S_STATCHANGED.statInfo)
  return _internal_statinfo();
}
inline void S_STATCHANGED::unsafe_arena_set_allocated_statinfo(
    ::Protocol::StatInfo* statinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statinfo_);
  }
  _impl_.statinfo_ = statinfo;
  if (statinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.S_STATCHANGED.statInfo)
}
inline ::Protocol::StatInfo* S_STATCHANGED::release_statinfo() {
  
  ::Protocol::StatInfo* temp = _impl_.statinfo_;
  _impl_.statinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::StatInfo* S_STATCHANGED::unsafe_arena_release_statinfo() {
  // @@protoc_insertion_point(field_release:Protocol.S_STATCHANGED.statInfo)
  
  ::Protocol::StatInfo* temp = _impl_.statinfo_;
  _impl_.statinfo_ = nullptr;
  return temp;
}
inline ::Protocol::StatInfo* S_STATCHANGED::_internal_mutable_statinfo() {
  
  if (_impl_.statinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::StatInfo>(GetArenaForAllocation());
    _impl_.statinfo_ = p;
  }
  return _impl_.statinfo_;
}
inline ::Protocol::StatInfo* S_STATCHANGED::mutable_statinfo() {
  ::Protocol::StatInfo* _msg = _internal_mutable_statinfo();
  // @@protoc_insertion_point(field_mutable:Protocol.S_STATCHANGED.statInfo)
  return _msg;
}
inline void S_STATCHANGED::set_allocated_statinfo(::Protocol::StatInfo* statinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statinfo_);
  }
  if (statinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statinfo));
    if (message_arena != submessage_arena) {
      statinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.statinfo_ = statinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.S_STATCHANGED.statInfo)
}

// -------------------------------------------------------------------

// S_LEVEL_UP

// uint64 object_id = 1;
inline void S_LEVEL_UP::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_LEVEL_UP::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_LEVEL_UP::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_LEVEL_UP.object_id)
  return _internal_object_id();
}
inline void S_LEVEL_UP::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_LEVEL_UP::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_LEVEL_UP.object_id)
}

// int32 level = 2;
inline void S_LEVEL_UP::clear_level() {
  _impl_.level_ = 0;
}
inline int32_t S_LEVEL_UP::_internal_level() const {
  return _impl_.level_;
}
inline int32_t S_LEVEL_UP::level() const {
  // @@protoc_insertion_point(field_get:Protocol.S_LEVEL_UP.level)
  return _internal_level();
}
inline void S_LEVEL_UP::_internal_set_level(int32_t value) {
  
  _impl_.level_ = value;
}
inline void S_LEVEL_UP::set_level(int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:Protocol.S_LEVEL_UP.level)
}

// -------------------------------------------------------------------

// C_UPGRADESKILL

// uint64 object_id = 1;
inline void C_UPGRADESKILL::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_UPGRADESKILL::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_UPGRADESKILL::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_UPGRADESKILL.object_id)
  return _internal_object_id();
}
inline void C_UPGRADESKILL::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_UPGRADESKILL::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_UPGRADESKILL.object_id)
}

// int32 skillId = 2;
inline void C_UPGRADESKILL::clear_skillid() {
  _impl_.skillid_ = 0;
}
inline int32_t C_UPGRADESKILL::_internal_skillid() const {
  return _impl_.skillid_;
}
inline int32_t C_UPGRADESKILL::skillid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_UPGRADESKILL.skillId)
  return _internal_skillid();
}
inline void C_UPGRADESKILL::_internal_set_skillid(int32_t value) {
  
  _impl_.skillid_ = value;
}
inline void C_UPGRADESKILL::set_skillid(int32_t value) {
  _internal_set_skillid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_UPGRADESKILL.skillId)
}

// -------------------------------------------------------------------

// S_UPGRADESKILL

// uint64 object_id = 1;
inline void S_UPGRADESKILL::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_UPGRADESKILL::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_UPGRADESKILL::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_UPGRADESKILL.object_id)
  return _internal_object_id();
}
inline void S_UPGRADESKILL::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_UPGRADESKILL::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_UPGRADESKILL.object_id)
}

// int32 skillId = 2;
inline void S_UPGRADESKILL::clear_skillid() {
  _impl_.skillid_ = 0;
}
inline int32_t S_UPGRADESKILL::_internal_skillid() const {
  return _impl_.skillid_;
}
inline int32_t S_UPGRADESKILL::skillid() const {
  // @@protoc_insertion_point(field_get:Protocol.S_UPGRADESKILL.skillId)
  return _internal_skillid();
}
inline void S_UPGRADESKILL::_internal_set_skillid(int32_t value) {
  
  _impl_.skillid_ = value;
}
inline void S_UPGRADESKILL::set_skillid(int32_t value) {
  _internal_set_skillid(value);
  // @@protoc_insertion_point(field_set:Protocol.S_UPGRADESKILL.skillId)
}

// int32 skillLevel = 3;
inline void S_UPGRADESKILL::clear_skilllevel() {
  _impl_.skilllevel_ = 0;
}
inline int32_t S_UPGRADESKILL::_internal_skilllevel() const {
  return _impl_.skilllevel_;
}
inline int32_t S_UPGRADESKILL::skilllevel() const {
  // @@protoc_insertion_point(field_get:Protocol.S_UPGRADESKILL.skillLevel)
  return _internal_skilllevel();
}
inline void S_UPGRADESKILL::_internal_set_skilllevel(int32_t value) {
  
  _impl_.skilllevel_ = value;
}
inline void S_UPGRADESKILL::set_skilllevel(int32_t value) {
  _internal_set_skilllevel(value);
  // @@protoc_insertion_point(field_set:Protocol.S_UPGRADESKILL.skillLevel)
}

// int32 leftPoint = 4;
inline void S_UPGRADESKILL::clear_leftpoint() {
  _impl_.leftpoint_ = 0;
}
inline int32_t S_UPGRADESKILL::_internal_leftpoint() const {
  return _impl_.leftpoint_;
}
inline int32_t S_UPGRADESKILL::leftpoint() const {
  // @@protoc_insertion_point(field_get:Protocol.S_UPGRADESKILL.leftPoint)
  return _internal_leftpoint();
}
inline void S_UPGRADESKILL::_internal_set_leftpoint(int32_t value) {
  
  _impl_.leftpoint_ = value;
}
inline void S_UPGRADESKILL::set_leftpoint(int32_t value) {
  _internal_set_leftpoint(value);
  // @@protoc_insertion_point(field_set:Protocol.S_UPGRADESKILL.leftPoint)
}

// -------------------------------------------------------------------

// C_QUEST

// repeated int32 questId = 1;
inline int C_QUEST::_internal_questid_size() const {
  return _impl_.questid_.size();
}
inline int C_QUEST::questid_size() const {
  return _internal_questid_size();
}
inline void C_QUEST::clear_questid() {
  _impl_.questid_.Clear();
}
inline int32_t C_QUEST::_internal_questid(int index) const {
  return _impl_.questid_.Get(index);
}
inline int32_t C_QUEST::questid(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.C_QUEST.questId)
  return _internal_questid(index);
}
inline void C_QUEST::set_questid(int index, int32_t value) {
  _impl_.questid_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.C_QUEST.questId)
}
inline void C_QUEST::_internal_add_questid(int32_t value) {
  _impl_.questid_.Add(value);
}
inline void C_QUEST::add_questid(int32_t value) {
  _internal_add_questid(value);
  // @@protoc_insertion_point(field_add:Protocol.C_QUEST.questId)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
C_QUEST::_internal_questid() const {
  return _impl_.questid_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
C_QUEST::questid() const {
  // @@protoc_insertion_point(field_list:Protocol.C_QUEST.questId)
  return _internal_questid();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
C_QUEST::_internal_mutable_questid() {
  return &_impl_.questid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
C_QUEST::mutable_questid() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.C_QUEST.questId)
  return _internal_mutable_questid();
}

// repeated .Protocol.EQuestState questState = 2;
inline int C_QUEST::_internal_queststate_size() const {
  return _impl_.queststate_.size();
}
inline int C_QUEST::queststate_size() const {
  return _internal_queststate_size();
}
inline void C_QUEST::clear_queststate() {
  _impl_.queststate_.Clear();
}
inline ::Protocol::EQuestState C_QUEST::_internal_queststate(int index) const {
  return static_cast< ::Protocol::EQuestState >(_impl_.queststate_.Get(index));
}
inline ::Protocol::EQuestState C_QUEST::queststate(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.C_QUEST.questState)
  return _internal_queststate(index);
}
inline void C_QUEST::set_queststate(int index, ::Protocol::EQuestState value) {
  _impl_.queststate_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.C_QUEST.questState)
}
inline void C_QUEST::_internal_add_queststate(::Protocol::EQuestState value) {
  _impl_.queststate_.Add(value);
}
inline void C_QUEST::add_queststate(::Protocol::EQuestState value) {
  _internal_add_queststate(value);
  // @@protoc_insertion_point(field_add:Protocol.C_QUEST.questState)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
C_QUEST::queststate() const {
  // @@protoc_insertion_point(field_list:Protocol.C_QUEST.questState)
  return _impl_.queststate_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
C_QUEST::_internal_mutable_queststate() {
  return &_impl_.queststate_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
C_QUEST::mutable_queststate() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.C_QUEST.questState)
  return _internal_mutable_queststate();
}

// -------------------------------------------------------------------

// S_QUEST

// repeated int32 questId = 1;
inline int S_QUEST::_internal_questid_size() const {
  return _impl_.questid_.size();
}
inline int S_QUEST::questid_size() const {
  return _internal_questid_size();
}
inline void S_QUEST::clear_questid() {
  _impl_.questid_.Clear();
}
inline int32_t S_QUEST::_internal_questid(int index) const {
  return _impl_.questid_.Get(index);
}
inline int32_t S_QUEST::questid(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_QUEST.questId)
  return _internal_questid(index);
}
inline void S_QUEST::set_questid(int index, int32_t value) {
  _impl_.questid_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.S_QUEST.questId)
}
inline void S_QUEST::_internal_add_questid(int32_t value) {
  _impl_.questid_.Add(value);
}
inline void S_QUEST::add_questid(int32_t value) {
  _internal_add_questid(value);
  // @@protoc_insertion_point(field_add:Protocol.S_QUEST.questId)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
S_QUEST::_internal_questid() const {
  return _impl_.questid_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
S_QUEST::questid() const {
  // @@protoc_insertion_point(field_list:Protocol.S_QUEST.questId)
  return _internal_questid();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
S_QUEST::_internal_mutable_questid() {
  return &_impl_.questid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
S_QUEST::mutable_questid() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_QUEST.questId)
  return _internal_mutable_questid();
}

// repeated .Protocol.EQuestState questState = 2;
inline int S_QUEST::_internal_queststate_size() const {
  return _impl_.queststate_.size();
}
inline int S_QUEST::queststate_size() const {
  return _internal_queststate_size();
}
inline void S_QUEST::clear_queststate() {
  _impl_.queststate_.Clear();
}
inline ::Protocol::EQuestState S_QUEST::_internal_queststate(int index) const {
  return static_cast< ::Protocol::EQuestState >(_impl_.queststate_.Get(index));
}
inline ::Protocol::EQuestState S_QUEST::queststate(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_QUEST.questState)
  return _internal_queststate(index);
}
inline void S_QUEST::set_queststate(int index, ::Protocol::EQuestState value) {
  _impl_.queststate_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.S_QUEST.questState)
}
inline void S_QUEST::_internal_add_queststate(::Protocol::EQuestState value) {
  _impl_.queststate_.Add(value);
}
inline void S_QUEST::add_queststate(::Protocol::EQuestState value) {
  _internal_add_queststate(value);
  // @@protoc_insertion_point(field_add:Protocol.S_QUEST.questState)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
S_QUEST::queststate() const {
  // @@protoc_insertion_point(field_list:Protocol.S_QUEST.questState)
  return _impl_.queststate_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
S_QUEST::_internal_mutable_queststate() {
  return &_impl_.queststate_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
S_QUEST::mutable_queststate() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_QUEST.questState)
  return _internal_mutable_queststate();
}

// -------------------------------------------------------------------

// C_RENEW_TARGET

// int32 targetId = 1;
inline void C_RENEW_TARGET::clear_targetid() {
  _impl_.targetid_ = 0;
}
inline int32_t C_RENEW_TARGET::_internal_targetid() const {
  return _impl_.targetid_;
}
inline int32_t C_RENEW_TARGET::targetid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_RENEW_TARGET.targetId)
  return _internal_targetid();
}
inline void C_RENEW_TARGET::_internal_set_targetid(int32_t value) {
  
  _impl_.targetid_ = value;
}
inline void C_RENEW_TARGET::set_targetid(int32_t value) {
  _internal_set_targetid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_RENEW_TARGET.targetId)
}

// int32 targetCount = 2;
inline void C_RENEW_TARGET::clear_targetcount() {
  _impl_.targetcount_ = 0;
}
inline int32_t C_RENEW_TARGET::_internal_targetcount() const {
  return _impl_.targetcount_;
}
inline int32_t C_RENEW_TARGET::targetcount() const {
  // @@protoc_insertion_point(field_get:Protocol.C_RENEW_TARGET.targetCount)
  return _internal_targetcount();
}
inline void C_RENEW_TARGET::_internal_set_targetcount(int32_t value) {
  
  _impl_.targetcount_ = value;
}
inline void C_RENEW_TARGET::set_targetcount(int32_t value) {
  _internal_set_targetcount(value);
  // @@protoc_insertion_point(field_set:Protocol.C_RENEW_TARGET.targetCount)
}

// .Protocol.ETargetType targetType = 3;
inline void C_RENEW_TARGET::clear_targettype() {
  _impl_.targettype_ = 0;
}
inline ::Protocol::ETargetType C_RENEW_TARGET::_internal_targettype() const {
  return static_cast< ::Protocol::ETargetType >(_impl_.targettype_);
}
inline ::Protocol::ETargetType C_RENEW_TARGET::targettype() const {
  // @@protoc_insertion_point(field_get:Protocol.C_RENEW_TARGET.targetType)
  return _internal_targettype();
}
inline void C_RENEW_TARGET::_internal_set_targettype(::Protocol::ETargetType value) {
  
  _impl_.targettype_ = value;
}
inline void C_RENEW_TARGET::set_targettype(::Protocol::ETargetType value) {
  _internal_set_targettype(value);
  // @@protoc_insertion_point(field_set:Protocol.C_RENEW_TARGET.targetType)
}

// int32 questId = 4;
inline void C_RENEW_TARGET::clear_questid() {
  _impl_.questid_ = 0;
}
inline int32_t C_RENEW_TARGET::_internal_questid() const {
  return _impl_.questid_;
}
inline int32_t C_RENEW_TARGET::questid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_RENEW_TARGET.questId)
  return _internal_questid();
}
inline void C_RENEW_TARGET::_internal_set_questid(int32_t value) {
  
  _impl_.questid_ = value;
}
inline void C_RENEW_TARGET::set_questid(int32_t value) {
  _internal_set_questid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_RENEW_TARGET.questId)
}

// -------------------------------------------------------------------

// S_LOAD_TARGET

// repeated int32 questId = 1;
inline int S_LOAD_TARGET::_internal_questid_size() const {
  return _impl_.questid_.size();
}
inline int S_LOAD_TARGET::questid_size() const {
  return _internal_questid_size();
}
inline void S_LOAD_TARGET::clear_questid() {
  _impl_.questid_.Clear();
}
inline int32_t S_LOAD_TARGET::_internal_questid(int index) const {
  return _impl_.questid_.Get(index);
}
inline int32_t S_LOAD_TARGET::questid(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_LOAD_TARGET.questId)
  return _internal_questid(index);
}
inline void S_LOAD_TARGET::set_questid(int index, int32_t value) {
  _impl_.questid_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.S_LOAD_TARGET.questId)
}
inline void S_LOAD_TARGET::_internal_add_questid(int32_t value) {
  _impl_.questid_.Add(value);
}
inline void S_LOAD_TARGET::add_questid(int32_t value) {
  _internal_add_questid(value);
  // @@protoc_insertion_point(field_add:Protocol.S_LOAD_TARGET.questId)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
S_LOAD_TARGET::_internal_questid() const {
  return _impl_.questid_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
S_LOAD_TARGET::questid() const {
  // @@protoc_insertion_point(field_list:Protocol.S_LOAD_TARGET.questId)
  return _internal_questid();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
S_LOAD_TARGET::_internal_mutable_questid() {
  return &_impl_.questid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
S_LOAD_TARGET::mutable_questid() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_LOAD_TARGET.questId)
  return _internal_mutable_questid();
}

// repeated int32 targetIndex = 2;
inline int S_LOAD_TARGET::_internal_targetindex_size() const {
  return _impl_.targetindex_.size();
}
inline int S_LOAD_TARGET::targetindex_size() const {
  return _internal_targetindex_size();
}
inline void S_LOAD_TARGET::clear_targetindex() {
  _impl_.targetindex_.Clear();
}
inline int32_t S_LOAD_TARGET::_internal_targetindex(int index) const {
  return _impl_.targetindex_.Get(index);
}
inline int32_t S_LOAD_TARGET::targetindex(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_LOAD_TARGET.targetIndex)
  return _internal_targetindex(index);
}
inline void S_LOAD_TARGET::set_targetindex(int index, int32_t value) {
  _impl_.targetindex_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.S_LOAD_TARGET.targetIndex)
}
inline void S_LOAD_TARGET::_internal_add_targetindex(int32_t value) {
  _impl_.targetindex_.Add(value);
}
inline void S_LOAD_TARGET::add_targetindex(int32_t value) {
  _internal_add_targetindex(value);
  // @@protoc_insertion_point(field_add:Protocol.S_LOAD_TARGET.targetIndex)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
S_LOAD_TARGET::_internal_targetindex() const {
  return _impl_.targetindex_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
S_LOAD_TARGET::targetindex() const {
  // @@protoc_insertion_point(field_list:Protocol.S_LOAD_TARGET.targetIndex)
  return _internal_targetindex();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
S_LOAD_TARGET::_internal_mutable_targetindex() {
  return &_impl_.targetindex_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
S_LOAD_TARGET::mutable_targetindex() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_LOAD_TARGET.targetIndex)
  return _internal_mutable_targetindex();
}

// repeated int32 targetCount = 3;
inline int S_LOAD_TARGET::_internal_targetcount_size() const {
  return _impl_.targetcount_.size();
}
inline int S_LOAD_TARGET::targetcount_size() const {
  return _internal_targetcount_size();
}
inline void S_LOAD_TARGET::clear_targetcount() {
  _impl_.targetcount_.Clear();
}
inline int32_t S_LOAD_TARGET::_internal_targetcount(int index) const {
  return _impl_.targetcount_.Get(index);
}
inline int32_t S_LOAD_TARGET::targetcount(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_LOAD_TARGET.targetCount)
  return _internal_targetcount(index);
}
inline void S_LOAD_TARGET::set_targetcount(int index, int32_t value) {
  _impl_.targetcount_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.S_LOAD_TARGET.targetCount)
}
inline void S_LOAD_TARGET::_internal_add_targetcount(int32_t value) {
  _impl_.targetcount_.Add(value);
}
inline void S_LOAD_TARGET::add_targetcount(int32_t value) {
  _internal_add_targetcount(value);
  // @@protoc_insertion_point(field_add:Protocol.S_LOAD_TARGET.targetCount)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
S_LOAD_TARGET::_internal_targetcount() const {
  return _impl_.targetcount_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
S_LOAD_TARGET::targetcount() const {
  // @@protoc_insertion_point(field_list:Protocol.S_LOAD_TARGET.targetCount)
  return _internal_targetcount();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
S_LOAD_TARGET::_internal_mutable_targetcount() {
  return &_impl_.targetcount_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
S_LOAD_TARGET::mutable_targetcount() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_LOAD_TARGET.targetCount)
  return _internal_mutable_targetcount();
}

// -------------------------------------------------------------------

// C_QUICK_QUEST

// uint64 object_id = 1;
inline void C_QUICK_QUEST::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t C_QUICK_QUEST::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t C_QUICK_QUEST::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.C_QUICK_QUEST.object_id)
  return _internal_object_id();
}
inline void C_QUICK_QUEST::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void C_QUICK_QUEST::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.C_QUICK_QUEST.object_id)
}

// int32 questId = 2;
inline void C_QUICK_QUEST::clear_questid() {
  _impl_.questid_ = 0;
}
inline int32_t C_QUICK_QUEST::_internal_questid() const {
  return _impl_.questid_;
}
inline int32_t C_QUICK_QUEST::questid() const {
  // @@protoc_insertion_point(field_get:Protocol.C_QUICK_QUEST.questId)
  return _internal_questid();
}
inline void C_QUICK_QUEST::_internal_set_questid(int32_t value) {
  
  _impl_.questid_ = value;
}
inline void C_QUICK_QUEST::set_questid(int32_t value) {
  _internal_set_questid(value);
  // @@protoc_insertion_point(field_set:Protocol.C_QUICK_QUEST.questId)
}

// bool isRemove = 3;
inline void C_QUICK_QUEST::clear_isremove() {
  _impl_.isremove_ = false;
}
inline bool C_QUICK_QUEST::_internal_isremove() const {
  return _impl_.isremove_;
}
inline bool C_QUICK_QUEST::isremove() const {
  // @@protoc_insertion_point(field_get:Protocol.C_QUICK_QUEST.isRemove)
  return _internal_isremove();
}
inline void C_QUICK_QUEST::_internal_set_isremove(bool value) {
  
  _impl_.isremove_ = value;
}
inline void C_QUICK_QUEST::set_isremove(bool value) {
  _internal_set_isremove(value);
  // @@protoc_insertion_point(field_set:Protocol.C_QUICK_QUEST.isRemove)
}

// -------------------------------------------------------------------

// S_QUICK_QUEST

// repeated int32 questId = 1;
inline int S_QUICK_QUEST::_internal_questid_size() const {
  return _impl_.questid_.size();
}
inline int S_QUICK_QUEST::questid_size() const {
  return _internal_questid_size();
}
inline void S_QUICK_QUEST::clear_questid() {
  _impl_.questid_.Clear();
}
inline int32_t S_QUICK_QUEST::_internal_questid(int index) const {
  return _impl_.questid_.Get(index);
}
inline int32_t S_QUICK_QUEST::questid(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S_QUICK_QUEST.questId)
  return _internal_questid(index);
}
inline void S_QUICK_QUEST::set_questid(int index, int32_t value) {
  _impl_.questid_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.S_QUICK_QUEST.questId)
}
inline void S_QUICK_QUEST::_internal_add_questid(int32_t value) {
  _impl_.questid_.Add(value);
}
inline void S_QUICK_QUEST::add_questid(int32_t value) {
  _internal_add_questid(value);
  // @@protoc_insertion_point(field_add:Protocol.S_QUICK_QUEST.questId)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
S_QUICK_QUEST::_internal_questid() const {
  return _impl_.questid_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
S_QUICK_QUEST::questid() const {
  // @@protoc_insertion_point(field_list:Protocol.S_QUICK_QUEST.questId)
  return _internal_questid();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
S_QUICK_QUEST::_internal_mutable_questid() {
  return &_impl_.questid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
S_QUICK_QUEST::mutable_questid() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S_QUICK_QUEST.questId)
  return _internal_mutable_questid();
}

// -------------------------------------------------------------------

// S_SET_DATA

// uint64 object_id = 1;
inline void S_SET_DATA::clear_object_id() {
  _impl_.object_id_ = uint64_t{0u};
}
inline uint64_t S_SET_DATA::_internal_object_id() const {
  return _impl_.object_id_;
}
inline uint64_t S_SET_DATA::object_id() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SET_DATA.object_id)
  return _internal_object_id();
}
inline void S_SET_DATA::_internal_set_object_id(uint64_t value) {
  
  _impl_.object_id_ = value;
}
inline void S_SET_DATA::set_object_id(uint64_t value) {
  _internal_set_object_id(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SET_DATA.object_id)
}

// .Protocol.EPlayerData dataType = 2;
inline void S_SET_DATA::clear_datatype() {
  _impl_.datatype_ = 0;
}
inline ::Protocol::EPlayerData S_SET_DATA::_internal_datatype() const {
  return static_cast< ::Protocol::EPlayerData >(_impl_.datatype_);
}
inline ::Protocol::EPlayerData S_SET_DATA::datatype() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SET_DATA.dataType)
  return _internal_datatype();
}
inline void S_SET_DATA::_internal_set_datatype(::Protocol::EPlayerData value) {
  
  _impl_.datatype_ = value;
}
inline void S_SET_DATA::set_datatype(::Protocol::EPlayerData value) {
  _internal_set_datatype(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SET_DATA.dataType)
}

// .Protocol.ECharacterType objectType = 3;
inline void S_SET_DATA::clear_objecttype() {
  _impl_.objecttype_ = 0;
}
inline ::Protocol::ECharacterType S_SET_DATA::_internal_objecttype() const {
  return static_cast< ::Protocol::ECharacterType >(_impl_.objecttype_);
}
inline ::Protocol::ECharacterType S_SET_DATA::objecttype() const {
  // @@protoc_insertion_point(field_get:Protocol.S_SET_DATA.objectType)
  return _internal_objecttype();
}
inline void S_SET_DATA::_internal_set_objecttype(::Protocol::ECharacterType value) {
  
  _impl_.objecttype_ = value;
}
inline void S_SET_DATA::set_objecttype(::Protocol::ECharacterType value) {
  _internal_set_objecttype(value);
  // @@protoc_insertion_point(field_set:Protocol.S_SET_DATA.objectType)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
